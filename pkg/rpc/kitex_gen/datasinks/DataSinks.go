// Code generated by thriftgo (0.2.7). DO NOT EDIT.

package datasinks

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/descriptors"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/exprs"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/partitions"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/plannodes"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/types"
	"strings"
)

type TDataSinkType int64

const (
	TDataSinkType_DATA_STREAM_SINK             TDataSinkType = 0
	TDataSinkType_RESULT_SINK                  TDataSinkType = 1
	TDataSinkType_DATA_SPLIT_SINK              TDataSinkType = 2
	TDataSinkType_MYSQL_TABLE_SINK             TDataSinkType = 3
	TDataSinkType_EXPORT_SINK                  TDataSinkType = 4
	TDataSinkType_OLAP_TABLE_SINK              TDataSinkType = 5
	TDataSinkType_MEMORY_SCRATCH_SINK          TDataSinkType = 6
	TDataSinkType_ODBC_TABLE_SINK              TDataSinkType = 7
	TDataSinkType_RESULT_FILE_SINK             TDataSinkType = 8
	TDataSinkType_JDBC_TABLE_SINK              TDataSinkType = 9
	TDataSinkType_MULTI_CAST_DATA_STREAM_SINK  TDataSinkType = 10
	TDataSinkType_GROUP_COMMIT_OLAP_TABLE_SINK TDataSinkType = 11
	TDataSinkType_GROUP_COMMIT_BLOCK_SINK      TDataSinkType = 12
)

func (p TDataSinkType) String() string {
	switch p {
	case TDataSinkType_DATA_STREAM_SINK:
		return "DATA_STREAM_SINK"
	case TDataSinkType_RESULT_SINK:
		return "RESULT_SINK"
	case TDataSinkType_DATA_SPLIT_SINK:
		return "DATA_SPLIT_SINK"
	case TDataSinkType_MYSQL_TABLE_SINK:
		return "MYSQL_TABLE_SINK"
	case TDataSinkType_EXPORT_SINK:
		return "EXPORT_SINK"
	case TDataSinkType_OLAP_TABLE_SINK:
		return "OLAP_TABLE_SINK"
	case TDataSinkType_MEMORY_SCRATCH_SINK:
		return "MEMORY_SCRATCH_SINK"
	case TDataSinkType_ODBC_TABLE_SINK:
		return "ODBC_TABLE_SINK"
	case TDataSinkType_RESULT_FILE_SINK:
		return "RESULT_FILE_SINK"
	case TDataSinkType_JDBC_TABLE_SINK:
		return "JDBC_TABLE_SINK"
	case TDataSinkType_MULTI_CAST_DATA_STREAM_SINK:
		return "MULTI_CAST_DATA_STREAM_SINK"
	case TDataSinkType_GROUP_COMMIT_OLAP_TABLE_SINK:
		return "GROUP_COMMIT_OLAP_TABLE_SINK"
	case TDataSinkType_GROUP_COMMIT_BLOCK_SINK:
		return "GROUP_COMMIT_BLOCK_SINK"
	}
	return "<UNSET>"
}

func TDataSinkTypeFromString(s string) (TDataSinkType, error) {
	switch s {
	case "DATA_STREAM_SINK":
		return TDataSinkType_DATA_STREAM_SINK, nil
	case "RESULT_SINK":
		return TDataSinkType_RESULT_SINK, nil
	case "DATA_SPLIT_SINK":
		return TDataSinkType_DATA_SPLIT_SINK, nil
	case "MYSQL_TABLE_SINK":
		return TDataSinkType_MYSQL_TABLE_SINK, nil
	case "EXPORT_SINK":
		return TDataSinkType_EXPORT_SINK, nil
	case "OLAP_TABLE_SINK":
		return TDataSinkType_OLAP_TABLE_SINK, nil
	case "MEMORY_SCRATCH_SINK":
		return TDataSinkType_MEMORY_SCRATCH_SINK, nil
	case "ODBC_TABLE_SINK":
		return TDataSinkType_ODBC_TABLE_SINK, nil
	case "RESULT_FILE_SINK":
		return TDataSinkType_RESULT_FILE_SINK, nil
	case "JDBC_TABLE_SINK":
		return TDataSinkType_JDBC_TABLE_SINK, nil
	case "MULTI_CAST_DATA_STREAM_SINK":
		return TDataSinkType_MULTI_CAST_DATA_STREAM_SINK, nil
	case "GROUP_COMMIT_OLAP_TABLE_SINK":
		return TDataSinkType_GROUP_COMMIT_OLAP_TABLE_SINK, nil
	case "GROUP_COMMIT_BLOCK_SINK":
		return TDataSinkType_GROUP_COMMIT_BLOCK_SINK, nil
	}
	return TDataSinkType(0), fmt.Errorf("not a valid TDataSinkType string")
}

func TDataSinkTypePtr(v TDataSinkType) *TDataSinkType { return &v }
func (p *TDataSinkType) Scan(value interface{}) (err error) {
	var result sql.NullInt64
	err = result.Scan(value)
	*p = TDataSinkType(result.Int64)
	return
}

func (p *TDataSinkType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TResultSinkType int64

const (
	TResultSinkType_MYSQL_PROTOCAL        TResultSinkType = 0
	TResultSinkType_ARROW_FLIGHT_PROTOCAL TResultSinkType = 1
	TResultSinkType_FILE                  TResultSinkType = 2
)

func (p TResultSinkType) String() string {
	switch p {
	case TResultSinkType_MYSQL_PROTOCAL:
		return "MYSQL_PROTOCAL"
	case TResultSinkType_ARROW_FLIGHT_PROTOCAL:
		return "ARROW_FLIGHT_PROTOCAL"
	case TResultSinkType_FILE:
		return "FILE"
	}
	return "<UNSET>"
}

func TResultSinkTypeFromString(s string) (TResultSinkType, error) {
	switch s {
	case "MYSQL_PROTOCAL":
		return TResultSinkType_MYSQL_PROTOCAL, nil
	case "ARROW_FLIGHT_PROTOCAL":
		return TResultSinkType_ARROW_FLIGHT_PROTOCAL, nil
	case "FILE":
		return TResultSinkType_FILE, nil
	}
	return TResultSinkType(0), fmt.Errorf("not a valid TResultSinkType string")
}

func TResultSinkTypePtr(v TResultSinkType) *TResultSinkType { return &v }
func (p *TResultSinkType) Scan(value interface{}) (err error) {
	var result sql.NullInt64
	err = result.Scan(value)
	*p = TResultSinkType(result.Int64)
	return
}

func (p *TResultSinkType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TParquetCompressionType int64

const (
	TParquetCompressionType_SNAPPY       TParquetCompressionType = 0
	TParquetCompressionType_GZIP         TParquetCompressionType = 1
	TParquetCompressionType_BROTLI       TParquetCompressionType = 2
	TParquetCompressionType_ZSTD         TParquetCompressionType = 3
	TParquetCompressionType_LZ4          TParquetCompressionType = 4
	TParquetCompressionType_LZO          TParquetCompressionType = 5
	TParquetCompressionType_BZ2          TParquetCompressionType = 6
	TParquetCompressionType_UNCOMPRESSED TParquetCompressionType = 7
)

func (p TParquetCompressionType) String() string {
	switch p {
	case TParquetCompressionType_SNAPPY:
		return "SNAPPY"
	case TParquetCompressionType_GZIP:
		return "GZIP"
	case TParquetCompressionType_BROTLI:
		return "BROTLI"
	case TParquetCompressionType_ZSTD:
		return "ZSTD"
	case TParquetCompressionType_LZ4:
		return "LZ4"
	case TParquetCompressionType_LZO:
		return "LZO"
	case TParquetCompressionType_BZ2:
		return "BZ2"
	case TParquetCompressionType_UNCOMPRESSED:
		return "UNCOMPRESSED"
	}
	return "<UNSET>"
}

func TParquetCompressionTypeFromString(s string) (TParquetCompressionType, error) {
	switch s {
	case "SNAPPY":
		return TParquetCompressionType_SNAPPY, nil
	case "GZIP":
		return TParquetCompressionType_GZIP, nil
	case "BROTLI":
		return TParquetCompressionType_BROTLI, nil
	case "ZSTD":
		return TParquetCompressionType_ZSTD, nil
	case "LZ4":
		return TParquetCompressionType_LZ4, nil
	case "LZO":
		return TParquetCompressionType_LZO, nil
	case "BZ2":
		return TParquetCompressionType_BZ2, nil
	case "UNCOMPRESSED":
		return TParquetCompressionType_UNCOMPRESSED, nil
	}
	return TParquetCompressionType(0), fmt.Errorf("not a valid TParquetCompressionType string")
}

func TParquetCompressionTypePtr(v TParquetCompressionType) *TParquetCompressionType { return &v }
func (p *TParquetCompressionType) Scan(value interface{}) (err error) {
	var result sql.NullInt64
	err = result.Scan(value)
	*p = TParquetCompressionType(result.Int64)
	return
}

func (p *TParquetCompressionType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TParquetVersion int64

const (
	TParquetVersion_PARQUET_1_0      TParquetVersion = 0
	TParquetVersion_PARQUET_2_LATEST TParquetVersion = 1
)

func (p TParquetVersion) String() string {
	switch p {
	case TParquetVersion_PARQUET_1_0:
		return "PARQUET_1_0"
	case TParquetVersion_PARQUET_2_LATEST:
		return "PARQUET_2_LATEST"
	}
	return "<UNSET>"
}

func TParquetVersionFromString(s string) (TParquetVersion, error) {
	switch s {
	case "PARQUET_1_0":
		return TParquetVersion_PARQUET_1_0, nil
	case "PARQUET_2_LATEST":
		return TParquetVersion_PARQUET_2_LATEST, nil
	}
	return TParquetVersion(0), fmt.Errorf("not a valid TParquetVersion string")
}

func TParquetVersionPtr(v TParquetVersion) *TParquetVersion { return &v }
func (p *TParquetVersion) Scan(value interface{}) (err error) {
	var result sql.NullInt64
	err = result.Scan(value)
	*p = TParquetVersion(result.Int64)
	return
}

func (p *TParquetVersion) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TParquetDataType int64

const (
	TParquetDataType_BOOLEAN              TParquetDataType = 0
	TParquetDataType_INT32                TParquetDataType = 1
	TParquetDataType_INT64                TParquetDataType = 2
	TParquetDataType_INT96                TParquetDataType = 3
	TParquetDataType_BYTE_ARRAY           TParquetDataType = 4
	TParquetDataType_FLOAT                TParquetDataType = 5
	TParquetDataType_DOUBLE               TParquetDataType = 6
	TParquetDataType_FIXED_LEN_BYTE_ARRAY TParquetDataType = 7
)

func (p TParquetDataType) String() string {
	switch p {
	case TParquetDataType_BOOLEAN:
		return "BOOLEAN"
	case TParquetDataType_INT32:
		return "INT32"
	case TParquetDataType_INT64:
		return "INT64"
	case TParquetDataType_INT96:
		return "INT96"
	case TParquetDataType_BYTE_ARRAY:
		return "BYTE_ARRAY"
	case TParquetDataType_FLOAT:
		return "FLOAT"
	case TParquetDataType_DOUBLE:
		return "DOUBLE"
	case TParquetDataType_FIXED_LEN_BYTE_ARRAY:
		return "FIXED_LEN_BYTE_ARRAY"
	}
	return "<UNSET>"
}

func TParquetDataTypeFromString(s string) (TParquetDataType, error) {
	switch s {
	case "BOOLEAN":
		return TParquetDataType_BOOLEAN, nil
	case "INT32":
		return TParquetDataType_INT32, nil
	case "INT64":
		return TParquetDataType_INT64, nil
	case "INT96":
		return TParquetDataType_INT96, nil
	case "BYTE_ARRAY":
		return TParquetDataType_BYTE_ARRAY, nil
	case "FLOAT":
		return TParquetDataType_FLOAT, nil
	case "DOUBLE":
		return TParquetDataType_DOUBLE, nil
	case "FIXED_LEN_BYTE_ARRAY":
		return TParquetDataType_FIXED_LEN_BYTE_ARRAY, nil
	}
	return TParquetDataType(0), fmt.Errorf("not a valid TParquetDataType string")
}

func TParquetDataTypePtr(v TParquetDataType) *TParquetDataType { return &v }
func (p *TParquetDataType) Scan(value interface{}) (err error) {
	var result sql.NullInt64
	err = result.Scan(value)
	*p = TParquetDataType(result.Int64)
	return
}

func (p *TParquetDataType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TParquetDataLogicalType int64

const (
	TParquetDataLogicalType_UNDEFINED TParquetDataLogicalType = 0
	TParquetDataLogicalType_STRING    TParquetDataLogicalType = 1
	TParquetDataLogicalType_MAP       TParquetDataLogicalType = 2
	TParquetDataLogicalType_LIST      TParquetDataLogicalType = 3
	TParquetDataLogicalType_ENUM      TParquetDataLogicalType = 4
	TParquetDataLogicalType_DECIMAL   TParquetDataLogicalType = 5
	TParquetDataLogicalType_DATE      TParquetDataLogicalType = 6
	TParquetDataLogicalType_TIME      TParquetDataLogicalType = 7
	TParquetDataLogicalType_TIMESTAMP TParquetDataLogicalType = 8
	TParquetDataLogicalType_INTERVAL  TParquetDataLogicalType = 9
	TParquetDataLogicalType_INT       TParquetDataLogicalType = 10
	TParquetDataLogicalType_NIL       TParquetDataLogicalType = 11
	TParquetDataLogicalType_JSON      TParquetDataLogicalType = 12
	TParquetDataLogicalType_BSON      TParquetDataLogicalType = 13
	TParquetDataLogicalType_UUID      TParquetDataLogicalType = 14
	TParquetDataLogicalType_NONE      TParquetDataLogicalType = 15
)

func (p TParquetDataLogicalType) String() string {
	switch p {
	case TParquetDataLogicalType_UNDEFINED:
		return "UNDEFINED"
	case TParquetDataLogicalType_STRING:
		return "STRING"
	case TParquetDataLogicalType_MAP:
		return "MAP"
	case TParquetDataLogicalType_LIST:
		return "LIST"
	case TParquetDataLogicalType_ENUM:
		return "ENUM"
	case TParquetDataLogicalType_DECIMAL:
		return "DECIMAL"
	case TParquetDataLogicalType_DATE:
		return "DATE"
	case TParquetDataLogicalType_TIME:
		return "TIME"
	case TParquetDataLogicalType_TIMESTAMP:
		return "TIMESTAMP"
	case TParquetDataLogicalType_INTERVAL:
		return "INTERVAL"
	case TParquetDataLogicalType_INT:
		return "INT"
	case TParquetDataLogicalType_NIL:
		return "NIL"
	case TParquetDataLogicalType_JSON:
		return "JSON"
	case TParquetDataLogicalType_BSON:
		return "BSON"
	case TParquetDataLogicalType_UUID:
		return "UUID"
	case TParquetDataLogicalType_NONE:
		return "NONE"
	}
	return "<UNSET>"
}

func TParquetDataLogicalTypeFromString(s string) (TParquetDataLogicalType, error) {
	switch s {
	case "UNDEFINED":
		return TParquetDataLogicalType_UNDEFINED, nil
	case "STRING":
		return TParquetDataLogicalType_STRING, nil
	case "MAP":
		return TParquetDataLogicalType_MAP, nil
	case "LIST":
		return TParquetDataLogicalType_LIST, nil
	case "ENUM":
		return TParquetDataLogicalType_ENUM, nil
	case "DECIMAL":
		return TParquetDataLogicalType_DECIMAL, nil
	case "DATE":
		return TParquetDataLogicalType_DATE, nil
	case "TIME":
		return TParquetDataLogicalType_TIME, nil
	case "TIMESTAMP":
		return TParquetDataLogicalType_TIMESTAMP, nil
	case "INTERVAL":
		return TParquetDataLogicalType_INTERVAL, nil
	case "INT":
		return TParquetDataLogicalType_INT, nil
	case "NIL":
		return TParquetDataLogicalType_NIL, nil
	case "JSON":
		return TParquetDataLogicalType_JSON, nil
	case "BSON":
		return TParquetDataLogicalType_BSON, nil
	case "UUID":
		return TParquetDataLogicalType_UUID, nil
	case "NONE":
		return TParquetDataLogicalType_NONE, nil
	}
	return TParquetDataLogicalType(0), fmt.Errorf("not a valid TParquetDataLogicalType string")
}

func TParquetDataLogicalTypePtr(v TParquetDataLogicalType) *TParquetDataLogicalType { return &v }
func (p *TParquetDataLogicalType) Scan(value interface{}) (err error) {
	var result sql.NullInt64
	err = result.Scan(value)
	*p = TParquetDataLogicalType(result.Int64)
	return
}

func (p *TParquetDataLogicalType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TParquetRepetitionType int64

const (
	TParquetRepetitionType_REQUIRED TParquetRepetitionType = 0
	TParquetRepetitionType_REPEATED TParquetRepetitionType = 1
	TParquetRepetitionType_OPTIONAL TParquetRepetitionType = 2
)

func (p TParquetRepetitionType) String() string {
	switch p {
	case TParquetRepetitionType_REQUIRED:
		return "REQUIRED"
	case TParquetRepetitionType_REPEATED:
		return "REPEATED"
	case TParquetRepetitionType_OPTIONAL:
		return "OPTIONAL"
	}
	return "<UNSET>"
}

func TParquetRepetitionTypeFromString(s string) (TParquetRepetitionType, error) {
	switch s {
	case "REQUIRED":
		return TParquetRepetitionType_REQUIRED, nil
	case "REPEATED":
		return TParquetRepetitionType_REPEATED, nil
	case "OPTIONAL":
		return TParquetRepetitionType_OPTIONAL, nil
	}
	return TParquetRepetitionType(0), fmt.Errorf("not a valid TParquetRepetitionType string")
}

func TParquetRepetitionTypePtr(v TParquetRepetitionType) *TParquetRepetitionType { return &v }
func (p *TParquetRepetitionType) Scan(value interface{}) (err error) {
	var result sql.NullInt64
	err = result.Scan(value)
	*p = TParquetRepetitionType(result.Int64)
	return
}

func (p *TParquetRepetitionType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TParquetSchema struct {
	SchemaRepetitionType  *TParquetRepetitionType  `thrift:"schema_repetition_type,1,optional" frugal:"1,optional,TParquetRepetitionType" json:"schema_repetition_type,omitempty"`
	SchemaDataType        *TParquetDataType        `thrift:"schema_data_type,2,optional" frugal:"2,optional,TParquetDataType" json:"schema_data_type,omitempty"`
	SchemaColumnName      *string                  `thrift:"schema_column_name,3,optional" frugal:"3,optional,string" json:"schema_column_name,omitempty"`
	SchemaDataLogicalType *TParquetDataLogicalType `thrift:"schema_data_logical_type,4,optional" frugal:"4,optional,TParquetDataLogicalType" json:"schema_data_logical_type,omitempty"`
}

func NewTParquetSchema() *TParquetSchema {
	return &TParquetSchema{}
}

func (p *TParquetSchema) InitDefault() {
	*p = TParquetSchema{}
}

var TParquetSchema_SchemaRepetitionType_DEFAULT TParquetRepetitionType

func (p *TParquetSchema) GetSchemaRepetitionType() (v TParquetRepetitionType) {
	if !p.IsSetSchemaRepetitionType() {
		return TParquetSchema_SchemaRepetitionType_DEFAULT
	}
	return *p.SchemaRepetitionType
}

var TParquetSchema_SchemaDataType_DEFAULT TParquetDataType

func (p *TParquetSchema) GetSchemaDataType() (v TParquetDataType) {
	if !p.IsSetSchemaDataType() {
		return TParquetSchema_SchemaDataType_DEFAULT
	}
	return *p.SchemaDataType
}

var TParquetSchema_SchemaColumnName_DEFAULT string

func (p *TParquetSchema) GetSchemaColumnName() (v string) {
	if !p.IsSetSchemaColumnName() {
		return TParquetSchema_SchemaColumnName_DEFAULT
	}
	return *p.SchemaColumnName
}

var TParquetSchema_SchemaDataLogicalType_DEFAULT TParquetDataLogicalType

func (p *TParquetSchema) GetSchemaDataLogicalType() (v TParquetDataLogicalType) {
	if !p.IsSetSchemaDataLogicalType() {
		return TParquetSchema_SchemaDataLogicalType_DEFAULT
	}
	return *p.SchemaDataLogicalType
}
func (p *TParquetSchema) SetSchemaRepetitionType(val *TParquetRepetitionType) {
	p.SchemaRepetitionType = val
}
func (p *TParquetSchema) SetSchemaDataType(val *TParquetDataType) {
	p.SchemaDataType = val
}
func (p *TParquetSchema) SetSchemaColumnName(val *string) {
	p.SchemaColumnName = val
}
func (p *TParquetSchema) SetSchemaDataLogicalType(val *TParquetDataLogicalType) {
	p.SchemaDataLogicalType = val
}

var fieldIDToName_TParquetSchema = map[int16]string{
	1: "schema_repetition_type",
	2: "schema_data_type",
	3: "schema_column_name",
	4: "schema_data_logical_type",
}

func (p *TParquetSchema) IsSetSchemaRepetitionType() bool {
	return p.SchemaRepetitionType != nil
}

func (p *TParquetSchema) IsSetSchemaDataType() bool {
	return p.SchemaDataType != nil
}

func (p *TParquetSchema) IsSetSchemaColumnName() bool {
	return p.SchemaColumnName != nil
}

func (p *TParquetSchema) IsSetSchemaDataLogicalType() bool {
	return p.SchemaDataLogicalType != nil
}

func (p *TParquetSchema) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TParquetSchema[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TParquetSchema) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		tmp := TParquetRepetitionType(v)
		p.SchemaRepetitionType = &tmp
	}
	return nil
}

func (p *TParquetSchema) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		tmp := TParquetDataType(v)
		p.SchemaDataType = &tmp
	}
	return nil
}

func (p *TParquetSchema) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.SchemaColumnName = &v
	}
	return nil
}

func (p *TParquetSchema) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		tmp := TParquetDataLogicalType(v)
		p.SchemaDataLogicalType = &tmp
	}
	return nil
}

func (p *TParquetSchema) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TParquetSchema"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TParquetSchema) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetSchemaRepetitionType() {
		if err = oprot.WriteFieldBegin("schema_repetition_type", thrift.I32, 1); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(int32(*p.SchemaRepetitionType)); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TParquetSchema) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSchemaDataType() {
		if err = oprot.WriteFieldBegin("schema_data_type", thrift.I32, 2); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(int32(*p.SchemaDataType)); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TParquetSchema) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetSchemaColumnName() {
		if err = oprot.WriteFieldBegin("schema_column_name", thrift.STRING, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.SchemaColumnName); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TParquetSchema) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSchemaDataLogicalType() {
		if err = oprot.WriteFieldBegin("schema_data_logical_type", thrift.I32, 4); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(int32(*p.SchemaDataLogicalType)); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TParquetSchema) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TParquetSchema(%+v)", *p)
}

func (p *TParquetSchema) DeepEqual(ano *TParquetSchema) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.SchemaRepetitionType) {
		return false
	}
	if !p.Field2DeepEqual(ano.SchemaDataType) {
		return false
	}
	if !p.Field3DeepEqual(ano.SchemaColumnName) {
		return false
	}
	if !p.Field4DeepEqual(ano.SchemaDataLogicalType) {
		return false
	}
	return true
}

func (p *TParquetSchema) Field1DeepEqual(src *TParquetRepetitionType) bool {

	if p.SchemaRepetitionType == src {
		return true
	} else if p.SchemaRepetitionType == nil || src == nil {
		return false
	}
	if *p.SchemaRepetitionType != *src {
		return false
	}
	return true
}
func (p *TParquetSchema) Field2DeepEqual(src *TParquetDataType) bool {

	if p.SchemaDataType == src {
		return true
	} else if p.SchemaDataType == nil || src == nil {
		return false
	}
	if *p.SchemaDataType != *src {
		return false
	}
	return true
}
func (p *TParquetSchema) Field3DeepEqual(src *string) bool {

	if p.SchemaColumnName == src {
		return true
	} else if p.SchemaColumnName == nil || src == nil {
		return false
	}
	if strings.Compare(*p.SchemaColumnName, *src) != 0 {
		return false
	}
	return true
}
func (p *TParquetSchema) Field4DeepEqual(src *TParquetDataLogicalType) bool {

	if p.SchemaDataLogicalType == src {
		return true
	} else if p.SchemaDataLogicalType == nil || src == nil {
		return false
	}
	if *p.SchemaDataLogicalType != *src {
		return false
	}
	return true
}

type TResultFileSinkOptions struct {
	FilePath                 string                    `thrift:"file_path,1,required" frugal:"1,required,string" json:"file_path"`
	FileFormat               plannodes.TFileFormatType `thrift:"file_format,2,required" frugal:"2,required,TFileFormatType" json:"file_format"`
	ColumnSeparator          *string                   `thrift:"column_separator,3,optional" frugal:"3,optional,string" json:"column_separator,omitempty"`
	LineDelimiter            *string                   `thrift:"line_delimiter,4,optional" frugal:"4,optional,string" json:"line_delimiter,omitempty"`
	MaxFileSizeBytes         *int64                    `thrift:"max_file_size_bytes,5,optional" frugal:"5,optional,i64" json:"max_file_size_bytes,omitempty"`
	BrokerAddresses          []*types.TNetworkAddress  `thrift:"broker_addresses,6,optional" frugal:"6,optional,list<types.TNetworkAddress>" json:"broker_addresses,omitempty"`
	BrokerProperties         map[string]string         `thrift:"broker_properties,7,optional" frugal:"7,optional,map<string:string>" json:"broker_properties,omitempty"`
	SuccessFileName          *string                   `thrift:"success_file_name,8,optional" frugal:"8,optional,string" json:"success_file_name,omitempty"`
	Schema                   [][]string                `thrift:"schema,9,optional" frugal:"9,optional,list<list<string>>" json:"schema,omitempty"`
	FileProperties           map[string]string         `thrift:"file_properties,10,optional" frugal:"10,optional,map<string:string>" json:"file_properties,omitempty"`
	ParquetSchemas           []*TParquetSchema         `thrift:"parquet_schemas,11,optional" frugal:"11,optional,list<TParquetSchema>" json:"parquet_schemas,omitempty"`
	ParquetCompressionType   *TParquetCompressionType  `thrift:"parquet_compression_type,12,optional" frugal:"12,optional,TParquetCompressionType" json:"parquet_compression_type,omitempty"`
	ParquetDisableDictionary *bool                     `thrift:"parquet_disable_dictionary,13,optional" frugal:"13,optional,bool" json:"parquet_disable_dictionary,omitempty"`
	ParquetVersion           *TParquetVersion          `thrift:"parquet_version,14,optional" frugal:"14,optional,TParquetVersion" json:"parquet_version,omitempty"`
	OrcSchema                *string                   `thrift:"orc_schema,15,optional" frugal:"15,optional,string" json:"orc_schema,omitempty"`
	DeleteExistingFiles      *bool                     `thrift:"delete_existing_files,16,optional" frugal:"16,optional,bool" json:"delete_existing_files,omitempty"`
	FileSuffix               *string                   `thrift:"file_suffix,17,optional" frugal:"17,optional,string" json:"file_suffix,omitempty"`
}

func NewTResultFileSinkOptions() *TResultFileSinkOptions {
	return &TResultFileSinkOptions{}
}

func (p *TResultFileSinkOptions) InitDefault() {
	*p = TResultFileSinkOptions{}
}

func (p *TResultFileSinkOptions) GetFilePath() (v string) {
	return p.FilePath
}

func (p *TResultFileSinkOptions) GetFileFormat() (v plannodes.TFileFormatType) {
	return p.FileFormat
}

var TResultFileSinkOptions_ColumnSeparator_DEFAULT string

func (p *TResultFileSinkOptions) GetColumnSeparator() (v string) {
	if !p.IsSetColumnSeparator() {
		return TResultFileSinkOptions_ColumnSeparator_DEFAULT
	}
	return *p.ColumnSeparator
}

var TResultFileSinkOptions_LineDelimiter_DEFAULT string

func (p *TResultFileSinkOptions) GetLineDelimiter() (v string) {
	if !p.IsSetLineDelimiter() {
		return TResultFileSinkOptions_LineDelimiter_DEFAULT
	}
	return *p.LineDelimiter
}

var TResultFileSinkOptions_MaxFileSizeBytes_DEFAULT int64

func (p *TResultFileSinkOptions) GetMaxFileSizeBytes() (v int64) {
	if !p.IsSetMaxFileSizeBytes() {
		return TResultFileSinkOptions_MaxFileSizeBytes_DEFAULT
	}
	return *p.MaxFileSizeBytes
}

var TResultFileSinkOptions_BrokerAddresses_DEFAULT []*types.TNetworkAddress

func (p *TResultFileSinkOptions) GetBrokerAddresses() (v []*types.TNetworkAddress) {
	if !p.IsSetBrokerAddresses() {
		return TResultFileSinkOptions_BrokerAddresses_DEFAULT
	}
	return p.BrokerAddresses
}

var TResultFileSinkOptions_BrokerProperties_DEFAULT map[string]string

func (p *TResultFileSinkOptions) GetBrokerProperties() (v map[string]string) {
	if !p.IsSetBrokerProperties() {
		return TResultFileSinkOptions_BrokerProperties_DEFAULT
	}
	return p.BrokerProperties
}

var TResultFileSinkOptions_SuccessFileName_DEFAULT string

func (p *TResultFileSinkOptions) GetSuccessFileName() (v string) {
	if !p.IsSetSuccessFileName() {
		return TResultFileSinkOptions_SuccessFileName_DEFAULT
	}
	return *p.SuccessFileName
}

var TResultFileSinkOptions_Schema_DEFAULT [][]string

func (p *TResultFileSinkOptions) GetSchema() (v [][]string) {
	if !p.IsSetSchema() {
		return TResultFileSinkOptions_Schema_DEFAULT
	}
	return p.Schema
}

var TResultFileSinkOptions_FileProperties_DEFAULT map[string]string

func (p *TResultFileSinkOptions) GetFileProperties() (v map[string]string) {
	if !p.IsSetFileProperties() {
		return TResultFileSinkOptions_FileProperties_DEFAULT
	}
	return p.FileProperties
}

var TResultFileSinkOptions_ParquetSchemas_DEFAULT []*TParquetSchema

func (p *TResultFileSinkOptions) GetParquetSchemas() (v []*TParquetSchema) {
	if !p.IsSetParquetSchemas() {
		return TResultFileSinkOptions_ParquetSchemas_DEFAULT
	}
	return p.ParquetSchemas
}

var TResultFileSinkOptions_ParquetCompressionType_DEFAULT TParquetCompressionType

func (p *TResultFileSinkOptions) GetParquetCompressionType() (v TParquetCompressionType) {
	if !p.IsSetParquetCompressionType() {
		return TResultFileSinkOptions_ParquetCompressionType_DEFAULT
	}
	return *p.ParquetCompressionType
}

var TResultFileSinkOptions_ParquetDisableDictionary_DEFAULT bool

func (p *TResultFileSinkOptions) GetParquetDisableDictionary() (v bool) {
	if !p.IsSetParquetDisableDictionary() {
		return TResultFileSinkOptions_ParquetDisableDictionary_DEFAULT
	}
	return *p.ParquetDisableDictionary
}

var TResultFileSinkOptions_ParquetVersion_DEFAULT TParquetVersion

func (p *TResultFileSinkOptions) GetParquetVersion() (v TParquetVersion) {
	if !p.IsSetParquetVersion() {
		return TResultFileSinkOptions_ParquetVersion_DEFAULT
	}
	return *p.ParquetVersion
}

var TResultFileSinkOptions_OrcSchema_DEFAULT string

func (p *TResultFileSinkOptions) GetOrcSchema() (v string) {
	if !p.IsSetOrcSchema() {
		return TResultFileSinkOptions_OrcSchema_DEFAULT
	}
	return *p.OrcSchema
}

var TResultFileSinkOptions_DeleteExistingFiles_DEFAULT bool

func (p *TResultFileSinkOptions) GetDeleteExistingFiles() (v bool) {
	if !p.IsSetDeleteExistingFiles() {
		return TResultFileSinkOptions_DeleteExistingFiles_DEFAULT
	}
	return *p.DeleteExistingFiles
}

var TResultFileSinkOptions_FileSuffix_DEFAULT string

func (p *TResultFileSinkOptions) GetFileSuffix() (v string) {
	if !p.IsSetFileSuffix() {
		return TResultFileSinkOptions_FileSuffix_DEFAULT
	}
	return *p.FileSuffix
}
func (p *TResultFileSinkOptions) SetFilePath(val string) {
	p.FilePath = val
}
func (p *TResultFileSinkOptions) SetFileFormat(val plannodes.TFileFormatType) {
	p.FileFormat = val
}
func (p *TResultFileSinkOptions) SetColumnSeparator(val *string) {
	p.ColumnSeparator = val
}
func (p *TResultFileSinkOptions) SetLineDelimiter(val *string) {
	p.LineDelimiter = val
}
func (p *TResultFileSinkOptions) SetMaxFileSizeBytes(val *int64) {
	p.MaxFileSizeBytes = val
}
func (p *TResultFileSinkOptions) SetBrokerAddresses(val []*types.TNetworkAddress) {
	p.BrokerAddresses = val
}
func (p *TResultFileSinkOptions) SetBrokerProperties(val map[string]string) {
	p.BrokerProperties = val
}
func (p *TResultFileSinkOptions) SetSuccessFileName(val *string) {
	p.SuccessFileName = val
}
func (p *TResultFileSinkOptions) SetSchema(val [][]string) {
	p.Schema = val
}
func (p *TResultFileSinkOptions) SetFileProperties(val map[string]string) {
	p.FileProperties = val
}
func (p *TResultFileSinkOptions) SetParquetSchemas(val []*TParquetSchema) {
	p.ParquetSchemas = val
}
func (p *TResultFileSinkOptions) SetParquetCompressionType(val *TParquetCompressionType) {
	p.ParquetCompressionType = val
}
func (p *TResultFileSinkOptions) SetParquetDisableDictionary(val *bool) {
	p.ParquetDisableDictionary = val
}
func (p *TResultFileSinkOptions) SetParquetVersion(val *TParquetVersion) {
	p.ParquetVersion = val
}
func (p *TResultFileSinkOptions) SetOrcSchema(val *string) {
	p.OrcSchema = val
}
func (p *TResultFileSinkOptions) SetDeleteExistingFiles(val *bool) {
	p.DeleteExistingFiles = val
}
func (p *TResultFileSinkOptions) SetFileSuffix(val *string) {
	p.FileSuffix = val
}

var fieldIDToName_TResultFileSinkOptions = map[int16]string{
	1:  "file_path",
	2:  "file_format",
	3:  "column_separator",
	4:  "line_delimiter",
	5:  "max_file_size_bytes",
	6:  "broker_addresses",
	7:  "broker_properties",
	8:  "success_file_name",
	9:  "schema",
	10: "file_properties",
	11: "parquet_schemas",
	12: "parquet_compression_type",
	13: "parquet_disable_dictionary",
	14: "parquet_version",
	15: "orc_schema",
	16: "delete_existing_files",
	17: "file_suffix",
}

func (p *TResultFileSinkOptions) IsSetColumnSeparator() bool {
	return p.ColumnSeparator != nil
}

func (p *TResultFileSinkOptions) IsSetLineDelimiter() bool {
	return p.LineDelimiter != nil
}

func (p *TResultFileSinkOptions) IsSetMaxFileSizeBytes() bool {
	return p.MaxFileSizeBytes != nil
}

func (p *TResultFileSinkOptions) IsSetBrokerAddresses() bool {
	return p.BrokerAddresses != nil
}

func (p *TResultFileSinkOptions) IsSetBrokerProperties() bool {
	return p.BrokerProperties != nil
}

func (p *TResultFileSinkOptions) IsSetSuccessFileName() bool {
	return p.SuccessFileName != nil
}

func (p *TResultFileSinkOptions) IsSetSchema() bool {
	return p.Schema != nil
}

func (p *TResultFileSinkOptions) IsSetFileProperties() bool {
	return p.FileProperties != nil
}

func (p *TResultFileSinkOptions) IsSetParquetSchemas() bool {
	return p.ParquetSchemas != nil
}

func (p *TResultFileSinkOptions) IsSetParquetCompressionType() bool {
	return p.ParquetCompressionType != nil
}

func (p *TResultFileSinkOptions) IsSetParquetDisableDictionary() bool {
	return p.ParquetDisableDictionary != nil
}

func (p *TResultFileSinkOptions) IsSetParquetVersion() bool {
	return p.ParquetVersion != nil
}

func (p *TResultFileSinkOptions) IsSetOrcSchema() bool {
	return p.OrcSchema != nil
}

func (p *TResultFileSinkOptions) IsSetDeleteExistingFiles() bool {
	return p.DeleteExistingFiles != nil
}

func (p *TResultFileSinkOptions) IsSetFileSuffix() bool {
	return p.FileSuffix != nil
}

func (p *TResultFileSinkOptions) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFilePath bool = false
	var issetFileFormat bool = false

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
				issetFilePath = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
				issetFileFormat = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err = p.ReadField5(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField6(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.MAP {
				if err = p.ReadField7(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField8(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField9(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.MAP {
				if err = p.ReadField10(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField11(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField12(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField13(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField14(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField15(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField16(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField17(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	if !issetFilePath {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetFileFormat {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TResultFileSinkOptions[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TResultFileSinkOptions[fieldId]))
}

func (p *TResultFileSinkOptions) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.FilePath = v
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.FileFormat = plannodes.TFileFormatType(v)
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.ColumnSeparator = &v
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.LineDelimiter = &v
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return err
	} else {
		p.MaxFileSizeBytes = &v
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField6(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.BrokerAddresses = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if err := _elem.Read(iprot); err != nil {
			return err
		}

		p.BrokerAddresses = append(p.BrokerAddresses, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField7(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return err
	}
	p.BrokerProperties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, err := iprot.ReadString(); err != nil {
			return err
		} else {
			_key = v
		}

		var _val string
		if v, err := iprot.ReadString(); err != nil {
			return err
		} else {
			_val = v
		}

		p.BrokerProperties[_key] = _val
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField8(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.SuccessFileName = &v
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField9(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.Schema = make([][]string, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return err
		}
		_elem := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem1 string
			if v, err := iprot.ReadString(); err != nil {
				return err
			} else {
				_elem1 = v
			}

			_elem = append(_elem, _elem1)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return err
		}

		p.Schema = append(p.Schema, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField10(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return err
	}
	p.FileProperties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, err := iprot.ReadString(); err != nil {
			return err
		} else {
			_key = v
		}

		var _val string
		if v, err := iprot.ReadString(); err != nil {
			return err
		} else {
			_val = v
		}

		p.FileProperties[_key] = _val
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField11(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.ParquetSchemas = make([]*TParquetSchema, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTParquetSchema()
		if err := _elem.Read(iprot); err != nil {
			return err
		}

		p.ParquetSchemas = append(p.ParquetSchemas, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField12(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		tmp := TParquetCompressionType(v)
		p.ParquetCompressionType = &tmp
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField13(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.ParquetDisableDictionary = &v
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField14(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		tmp := TParquetVersion(v)
		p.ParquetVersion = &tmp
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField15(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.OrcSchema = &v
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField16(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.DeleteExistingFiles = &v
	}
	return nil
}

func (p *TResultFileSinkOptions) ReadField17(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.FileSuffix = &v
	}
	return nil
}

func (p *TResultFileSinkOptions) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TResultFileSinkOptions"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}
		if err = p.writeField5(oprot); err != nil {
			fieldId = 5
			goto WriteFieldError
		}
		if err = p.writeField6(oprot); err != nil {
			fieldId = 6
			goto WriteFieldError
		}
		if err = p.writeField7(oprot); err != nil {
			fieldId = 7
			goto WriteFieldError
		}
		if err = p.writeField8(oprot); err != nil {
			fieldId = 8
			goto WriteFieldError
		}
		if err = p.writeField9(oprot); err != nil {
			fieldId = 9
			goto WriteFieldError
		}
		if err = p.writeField10(oprot); err != nil {
			fieldId = 10
			goto WriteFieldError
		}
		if err = p.writeField11(oprot); err != nil {
			fieldId = 11
			goto WriteFieldError
		}
		if err = p.writeField12(oprot); err != nil {
			fieldId = 12
			goto WriteFieldError
		}
		if err = p.writeField13(oprot); err != nil {
			fieldId = 13
			goto WriteFieldError
		}
		if err = p.writeField14(oprot); err != nil {
			fieldId = 14
			goto WriteFieldError
		}
		if err = p.writeField15(oprot); err != nil {
			fieldId = 15
			goto WriteFieldError
		}
		if err = p.writeField16(oprot); err != nil {
			fieldId = 16
			goto WriteFieldError
		}
		if err = p.writeField17(oprot); err != nil {
			fieldId = 17
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField1(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("file_path", thrift.STRING, 1); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.FilePath); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField2(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("file_format", thrift.I32, 2); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI32(int32(p.FileFormat)); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnSeparator() {
		if err = oprot.WriteFieldBegin("column_separator", thrift.STRING, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.ColumnSeparator); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetLineDelimiter() {
		if err = oprot.WriteFieldBegin("line_delimiter", thrift.STRING, 4); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.LineDelimiter); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetMaxFileSizeBytes() {
		if err = oprot.WriteFieldBegin("max_file_size_bytes", thrift.I64, 5); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI64(*p.MaxFileSizeBytes); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetBrokerAddresses() {
		if err = oprot.WriteFieldBegin("broker_addresses", thrift.LIST, 6); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.BrokerAddresses)); err != nil {
			return err
		}
		for _, v := range p.BrokerAddresses {
			if err := v.Write(oprot); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField7(oprot thrift.TProtocol) (err error) {
	if p.IsSetBrokerProperties() {
		if err = oprot.WriteFieldBegin("broker_properties", thrift.MAP, 7); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.BrokerProperties)); err != nil {
			return err
		}
		for k, v := range p.BrokerProperties {

			if err := oprot.WriteString(k); err != nil {
				return err
			}

			if err := oprot.WriteString(v); err != nil {
				return err
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField8(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccessFileName() {
		if err = oprot.WriteFieldBegin("success_file_name", thrift.STRING, 8); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.SuccessFileName); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 8 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 8 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField9(oprot thrift.TProtocol) (err error) {
	if p.IsSetSchema() {
		if err = oprot.WriteFieldBegin("schema", thrift.LIST, 9); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Schema)); err != nil {
			return err
		}
		for _, v := range p.Schema {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return err
			}
			for _, v := range v {
				if err := oprot.WriteString(v); err != nil {
					return err
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 9 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 9 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField10(oprot thrift.TProtocol) (err error) {
	if p.IsSetFileProperties() {
		if err = oprot.WriteFieldBegin("file_properties", thrift.MAP, 10); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.FileProperties)); err != nil {
			return err
		}
		for k, v := range p.FileProperties {

			if err := oprot.WriteString(k); err != nil {
				return err
			}

			if err := oprot.WriteString(v); err != nil {
				return err
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 10 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 10 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField11(oprot thrift.TProtocol) (err error) {
	if p.IsSetParquetSchemas() {
		if err = oprot.WriteFieldBegin("parquet_schemas", thrift.LIST, 11); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ParquetSchemas)); err != nil {
			return err
		}
		for _, v := range p.ParquetSchemas {
			if err := v.Write(oprot); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 11 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 11 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField12(oprot thrift.TProtocol) (err error) {
	if p.IsSetParquetCompressionType() {
		if err = oprot.WriteFieldBegin("parquet_compression_type", thrift.I32, 12); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(int32(*p.ParquetCompressionType)); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 12 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 12 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField13(oprot thrift.TProtocol) (err error) {
	if p.IsSetParquetDisableDictionary() {
		if err = oprot.WriteFieldBegin("parquet_disable_dictionary", thrift.BOOL, 13); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.ParquetDisableDictionary); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 13 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 13 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField14(oprot thrift.TProtocol) (err error) {
	if p.IsSetParquetVersion() {
		if err = oprot.WriteFieldBegin("parquet_version", thrift.I32, 14); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(int32(*p.ParquetVersion)); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 14 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 14 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField15(oprot thrift.TProtocol) (err error) {
	if p.IsSetOrcSchema() {
		if err = oprot.WriteFieldBegin("orc_schema", thrift.STRING, 15); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.OrcSchema); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 15 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 15 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField16(oprot thrift.TProtocol) (err error) {
	if p.IsSetDeleteExistingFiles() {
		if err = oprot.WriteFieldBegin("delete_existing_files", thrift.BOOL, 16); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.DeleteExistingFiles); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 16 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 16 end error: ", p), err)
}

func (p *TResultFileSinkOptions) writeField17(oprot thrift.TProtocol) (err error) {
	if p.IsSetFileSuffix() {
		if err = oprot.WriteFieldBegin("file_suffix", thrift.STRING, 17); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.FileSuffix); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 17 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 17 end error: ", p), err)
}

func (p *TResultFileSinkOptions) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TResultFileSinkOptions(%+v)", *p)
}

func (p *TResultFileSinkOptions) DeepEqual(ano *TResultFileSinkOptions) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.FilePath) {
		return false
	}
	if !p.Field2DeepEqual(ano.FileFormat) {
		return false
	}
	if !p.Field3DeepEqual(ano.ColumnSeparator) {
		return false
	}
	if !p.Field4DeepEqual(ano.LineDelimiter) {
		return false
	}
	if !p.Field5DeepEqual(ano.MaxFileSizeBytes) {
		return false
	}
	if !p.Field6DeepEqual(ano.BrokerAddresses) {
		return false
	}
	if !p.Field7DeepEqual(ano.BrokerProperties) {
		return false
	}
	if !p.Field8DeepEqual(ano.SuccessFileName) {
		return false
	}
	if !p.Field9DeepEqual(ano.Schema) {
		return false
	}
	if !p.Field10DeepEqual(ano.FileProperties) {
		return false
	}
	if !p.Field11DeepEqual(ano.ParquetSchemas) {
		return false
	}
	if !p.Field12DeepEqual(ano.ParquetCompressionType) {
		return false
	}
	if !p.Field13DeepEqual(ano.ParquetDisableDictionary) {
		return false
	}
	if !p.Field14DeepEqual(ano.ParquetVersion) {
		return false
	}
	if !p.Field15DeepEqual(ano.OrcSchema) {
		return false
	}
	if !p.Field16DeepEqual(ano.DeleteExistingFiles) {
		return false
	}
	if !p.Field17DeepEqual(ano.FileSuffix) {
		return false
	}
	return true
}

func (p *TResultFileSinkOptions) Field1DeepEqual(src string) bool {

	if strings.Compare(p.FilePath, src) != 0 {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field2DeepEqual(src plannodes.TFileFormatType) bool {

	if p.FileFormat != src {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field3DeepEqual(src *string) bool {

	if p.ColumnSeparator == src {
		return true
	} else if p.ColumnSeparator == nil || src == nil {
		return false
	}
	if strings.Compare(*p.ColumnSeparator, *src) != 0 {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field4DeepEqual(src *string) bool {

	if p.LineDelimiter == src {
		return true
	} else if p.LineDelimiter == nil || src == nil {
		return false
	}
	if strings.Compare(*p.LineDelimiter, *src) != 0 {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field5DeepEqual(src *int64) bool {

	if p.MaxFileSizeBytes == src {
		return true
	} else if p.MaxFileSizeBytes == nil || src == nil {
		return false
	}
	if *p.MaxFileSizeBytes != *src {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field6DeepEqual(src []*types.TNetworkAddress) bool {

	if len(p.BrokerAddresses) != len(src) {
		return false
	}
	for i, v := range p.BrokerAddresses {
		_src := src[i]
		if !v.DeepEqual(_src) {
			return false
		}
	}
	return true
}
func (p *TResultFileSinkOptions) Field7DeepEqual(src map[string]string) bool {

	if len(p.BrokerProperties) != len(src) {
		return false
	}
	for k, v := range p.BrokerProperties {
		_src := src[k]
		if strings.Compare(v, _src) != 0 {
			return false
		}
	}
	return true
}
func (p *TResultFileSinkOptions) Field8DeepEqual(src *string) bool {

	if p.SuccessFileName == src {
		return true
	} else if p.SuccessFileName == nil || src == nil {
		return false
	}
	if strings.Compare(*p.SuccessFileName, *src) != 0 {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field9DeepEqual(src [][]string) bool {

	if len(p.Schema) != len(src) {
		return false
	}
	for i, v := range p.Schema {
		_src := src[i]
		if len(v) != len(_src) {
			return false
		}
		for i, v := range v {
			_src1 := _src[i]
			if strings.Compare(v, _src1) != 0 {
				return false
			}
		}
	}
	return true
}
func (p *TResultFileSinkOptions) Field10DeepEqual(src map[string]string) bool {

	if len(p.FileProperties) != len(src) {
		return false
	}
	for k, v := range p.FileProperties {
		_src := src[k]
		if strings.Compare(v, _src) != 0 {
			return false
		}
	}
	return true
}
func (p *TResultFileSinkOptions) Field11DeepEqual(src []*TParquetSchema) bool {

	if len(p.ParquetSchemas) != len(src) {
		return false
	}
	for i, v := range p.ParquetSchemas {
		_src := src[i]
		if !v.DeepEqual(_src) {
			return false
		}
	}
	return true
}
func (p *TResultFileSinkOptions) Field12DeepEqual(src *TParquetCompressionType) bool {

	if p.ParquetCompressionType == src {
		return true
	} else if p.ParquetCompressionType == nil || src == nil {
		return false
	}
	if *p.ParquetCompressionType != *src {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field13DeepEqual(src *bool) bool {

	if p.ParquetDisableDictionary == src {
		return true
	} else if p.ParquetDisableDictionary == nil || src == nil {
		return false
	}
	if *p.ParquetDisableDictionary != *src {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field14DeepEqual(src *TParquetVersion) bool {

	if p.ParquetVersion == src {
		return true
	} else if p.ParquetVersion == nil || src == nil {
		return false
	}
	if *p.ParquetVersion != *src {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field15DeepEqual(src *string) bool {

	if p.OrcSchema == src {
		return true
	} else if p.OrcSchema == nil || src == nil {
		return false
	}
	if strings.Compare(*p.OrcSchema, *src) != 0 {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field16DeepEqual(src *bool) bool {

	if p.DeleteExistingFiles == src {
		return true
	} else if p.DeleteExistingFiles == nil || src == nil {
		return false
	}
	if *p.DeleteExistingFiles != *src {
		return false
	}
	return true
}
func (p *TResultFileSinkOptions) Field17DeepEqual(src *string) bool {

	if p.FileSuffix == src {
		return true
	} else if p.FileSuffix == nil || src == nil {
		return false
	}
	if strings.Compare(*p.FileSuffix, *src) != 0 {
		return false
	}
	return true
}

type TMemoryScratchSink struct {
}

func NewTMemoryScratchSink() *TMemoryScratchSink {
	return &TMemoryScratchSink{}
}

func (p *TMemoryScratchSink) InitDefault() {
	*p = TMemoryScratchSink{}
}

var fieldIDToName_TMemoryScratchSink = map[int16]string{}

func (p *TMemoryScratchSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err = iprot.Skip(fieldTypeId); err != nil {
			goto SkipFieldTypeError
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
SkipFieldTypeError:
	return thrift.PrependError(fmt.Sprintf("%T skip field type %d error", p, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TMemoryScratchSink) Write(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteStructBegin("TMemoryScratchSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TMemoryScratchSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TMemoryScratchSink(%+v)", *p)
}

func (p *TMemoryScratchSink) DeepEqual(ano *TMemoryScratchSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	return true
}

type TPlanFragmentDestination struct {
	FragmentInstanceId *types.TUniqueId       `thrift:"fragment_instance_id,1,required" frugal:"1,required,types.TUniqueId" json:"fragment_instance_id"`
	Server             *types.TNetworkAddress `thrift:"server,2,required" frugal:"2,required,types.TNetworkAddress" json:"server"`
	BrpcServer         *types.TNetworkAddress `thrift:"brpc_server,3,optional" frugal:"3,optional,types.TNetworkAddress" json:"brpc_server,omitempty"`
}

func NewTPlanFragmentDestination() *TPlanFragmentDestination {
	return &TPlanFragmentDestination{}
}

func (p *TPlanFragmentDestination) InitDefault() {
	*p = TPlanFragmentDestination{}
}

var TPlanFragmentDestination_FragmentInstanceId_DEFAULT *types.TUniqueId

func (p *TPlanFragmentDestination) GetFragmentInstanceId() (v *types.TUniqueId) {
	if !p.IsSetFragmentInstanceId() {
		return TPlanFragmentDestination_FragmentInstanceId_DEFAULT
	}
	return p.FragmentInstanceId
}

var TPlanFragmentDestination_Server_DEFAULT *types.TNetworkAddress

func (p *TPlanFragmentDestination) GetServer() (v *types.TNetworkAddress) {
	if !p.IsSetServer() {
		return TPlanFragmentDestination_Server_DEFAULT
	}
	return p.Server
}

var TPlanFragmentDestination_BrpcServer_DEFAULT *types.TNetworkAddress

func (p *TPlanFragmentDestination) GetBrpcServer() (v *types.TNetworkAddress) {
	if !p.IsSetBrpcServer() {
		return TPlanFragmentDestination_BrpcServer_DEFAULT
	}
	return p.BrpcServer
}
func (p *TPlanFragmentDestination) SetFragmentInstanceId(val *types.TUniqueId) {
	p.FragmentInstanceId = val
}
func (p *TPlanFragmentDestination) SetServer(val *types.TNetworkAddress) {
	p.Server = val
}
func (p *TPlanFragmentDestination) SetBrpcServer(val *types.TNetworkAddress) {
	p.BrpcServer = val
}

var fieldIDToName_TPlanFragmentDestination = map[int16]string{
	1: "fragment_instance_id",
	2: "server",
	3: "brpc_server",
}

func (p *TPlanFragmentDestination) IsSetFragmentInstanceId() bool {
	return p.FragmentInstanceId != nil
}

func (p *TPlanFragmentDestination) IsSetServer() bool {
	return p.Server != nil
}

func (p *TPlanFragmentDestination) IsSetBrpcServer() bool {
	return p.BrpcServer != nil
}

func (p *TPlanFragmentDestination) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFragmentInstanceId bool = false
	var issetServer bool = false

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
				issetFragmentInstanceId = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
				issetServer = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	if !issetFragmentInstanceId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetServer {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPlanFragmentDestination[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TPlanFragmentDestination[fieldId]))
}

func (p *TPlanFragmentDestination) ReadField1(iprot thrift.TProtocol) error {
	p.FragmentInstanceId = types.NewTUniqueId()
	if err := p.FragmentInstanceId.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TPlanFragmentDestination) ReadField2(iprot thrift.TProtocol) error {
	p.Server = types.NewTNetworkAddress()
	if err := p.Server.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TPlanFragmentDestination) ReadField3(iprot thrift.TProtocol) error {
	p.BrpcServer = types.NewTNetworkAddress()
	if err := p.BrpcServer.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TPlanFragmentDestination) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TPlanFragmentDestination"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TPlanFragmentDestination) writeField1(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("fragment_instance_id", thrift.STRUCT, 1); err != nil {
		goto WriteFieldBeginError
	}
	if err := p.FragmentInstanceId.Write(oprot); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TPlanFragmentDestination) writeField2(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("server", thrift.STRUCT, 2); err != nil {
		goto WriteFieldBeginError
	}
	if err := p.Server.Write(oprot); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TPlanFragmentDestination) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetBrpcServer() {
		if err = oprot.WriteFieldBegin("brpc_server", thrift.STRUCT, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.BrpcServer.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TPlanFragmentDestination) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TPlanFragmentDestination(%+v)", *p)
}

func (p *TPlanFragmentDestination) DeepEqual(ano *TPlanFragmentDestination) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.FragmentInstanceId) {
		return false
	}
	if !p.Field2DeepEqual(ano.Server) {
		return false
	}
	if !p.Field3DeepEqual(ano.BrpcServer) {
		return false
	}
	return true
}

func (p *TPlanFragmentDestination) Field1DeepEqual(src *types.TUniqueId) bool {

	if !p.FragmentInstanceId.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TPlanFragmentDestination) Field2DeepEqual(src *types.TNetworkAddress) bool {

	if !p.Server.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TPlanFragmentDestination) Field3DeepEqual(src *types.TNetworkAddress) bool {

	if !p.BrpcServer.DeepEqual(src) {
		return false
	}
	return true
}

type TDataStreamSink struct {
	DestNodeId      types.TPlanNodeId               `thrift:"dest_node_id,1,required" frugal:"1,required,i32" json:"dest_node_id"`
	OutputPartition *partitions.TDataPartition      `thrift:"output_partition,2,required" frugal:"2,required,partitions.TDataPartition" json:"output_partition"`
	IgnoreNotFound  *bool                           `thrift:"ignore_not_found,3,optional" frugal:"3,optional,bool" json:"ignore_not_found,omitempty"`
	OutputExprs     []*exprs.TExpr                  `thrift:"output_exprs,4,optional" frugal:"4,optional,list<exprs.TExpr>" json:"output_exprs,omitempty"`
	OutputTupleId   *types.TTupleId                 `thrift:"output_tuple_id,5,optional" frugal:"5,optional,i32" json:"output_tuple_id,omitempty"`
	Conjuncts       []*exprs.TExpr                  `thrift:"conjuncts,6,optional" frugal:"6,optional,list<exprs.TExpr>" json:"conjuncts,omitempty"`
	RuntimeFilters  []*plannodes.TRuntimeFilterDesc `thrift:"runtime_filters,7,optional" frugal:"7,optional,list<plannodes.TRuntimeFilterDesc>" json:"runtime_filters,omitempty"`
}

func NewTDataStreamSink() *TDataStreamSink {
	return &TDataStreamSink{}
}

func (p *TDataStreamSink) InitDefault() {
	*p = TDataStreamSink{}
}

func (p *TDataStreamSink) GetDestNodeId() (v types.TPlanNodeId) {
	return p.DestNodeId
}

var TDataStreamSink_OutputPartition_DEFAULT *partitions.TDataPartition

func (p *TDataStreamSink) GetOutputPartition() (v *partitions.TDataPartition) {
	if !p.IsSetOutputPartition() {
		return TDataStreamSink_OutputPartition_DEFAULT
	}
	return p.OutputPartition
}

var TDataStreamSink_IgnoreNotFound_DEFAULT bool

func (p *TDataStreamSink) GetIgnoreNotFound() (v bool) {
	if !p.IsSetIgnoreNotFound() {
		return TDataStreamSink_IgnoreNotFound_DEFAULT
	}
	return *p.IgnoreNotFound
}

var TDataStreamSink_OutputExprs_DEFAULT []*exprs.TExpr

func (p *TDataStreamSink) GetOutputExprs() (v []*exprs.TExpr) {
	if !p.IsSetOutputExprs() {
		return TDataStreamSink_OutputExprs_DEFAULT
	}
	return p.OutputExprs
}

var TDataStreamSink_OutputTupleId_DEFAULT types.TTupleId

func (p *TDataStreamSink) GetOutputTupleId() (v types.TTupleId) {
	if !p.IsSetOutputTupleId() {
		return TDataStreamSink_OutputTupleId_DEFAULT
	}
	return *p.OutputTupleId
}

var TDataStreamSink_Conjuncts_DEFAULT []*exprs.TExpr

func (p *TDataStreamSink) GetConjuncts() (v []*exprs.TExpr) {
	if !p.IsSetConjuncts() {
		return TDataStreamSink_Conjuncts_DEFAULT
	}
	return p.Conjuncts
}

var TDataStreamSink_RuntimeFilters_DEFAULT []*plannodes.TRuntimeFilterDesc

func (p *TDataStreamSink) GetRuntimeFilters() (v []*plannodes.TRuntimeFilterDesc) {
	if !p.IsSetRuntimeFilters() {
		return TDataStreamSink_RuntimeFilters_DEFAULT
	}
	return p.RuntimeFilters
}
func (p *TDataStreamSink) SetDestNodeId(val types.TPlanNodeId) {
	p.DestNodeId = val
}
func (p *TDataStreamSink) SetOutputPartition(val *partitions.TDataPartition) {
	p.OutputPartition = val
}
func (p *TDataStreamSink) SetIgnoreNotFound(val *bool) {
	p.IgnoreNotFound = val
}
func (p *TDataStreamSink) SetOutputExprs(val []*exprs.TExpr) {
	p.OutputExprs = val
}
func (p *TDataStreamSink) SetOutputTupleId(val *types.TTupleId) {
	p.OutputTupleId = val
}
func (p *TDataStreamSink) SetConjuncts(val []*exprs.TExpr) {
	p.Conjuncts = val
}
func (p *TDataStreamSink) SetRuntimeFilters(val []*plannodes.TRuntimeFilterDesc) {
	p.RuntimeFilters = val
}

var fieldIDToName_TDataStreamSink = map[int16]string{
	1: "dest_node_id",
	2: "output_partition",
	3: "ignore_not_found",
	4: "output_exprs",
	5: "output_tuple_id",
	6: "conjuncts",
	7: "runtime_filters",
}

func (p *TDataStreamSink) IsSetOutputPartition() bool {
	return p.OutputPartition != nil
}

func (p *TDataStreamSink) IsSetIgnoreNotFound() bool {
	return p.IgnoreNotFound != nil
}

func (p *TDataStreamSink) IsSetOutputExprs() bool {
	return p.OutputExprs != nil
}

func (p *TDataStreamSink) IsSetOutputTupleId() bool {
	return p.OutputTupleId != nil
}

func (p *TDataStreamSink) IsSetConjuncts() bool {
	return p.Conjuncts != nil
}

func (p *TDataStreamSink) IsSetRuntimeFilters() bool {
	return p.RuntimeFilters != nil
}

func (p *TDataStreamSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16
	var issetDestNodeId bool = false
	var issetOutputPartition bool = false

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
				issetDestNodeId = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
				issetOutputPartition = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField5(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField6(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField7(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	if !issetDestNodeId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetOutputPartition {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TDataStreamSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TDataStreamSink[fieldId]))
}

func (p *TDataStreamSink) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.DestNodeId = v
	}
	return nil
}

func (p *TDataStreamSink) ReadField2(iprot thrift.TProtocol) error {
	p.OutputPartition = partitions.NewTDataPartition()
	if err := p.OutputPartition.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataStreamSink) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.IgnoreNotFound = &v
	}
	return nil
}

func (p *TDataStreamSink) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.OutputExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if err := _elem.Read(iprot); err != nil {
			return err
		}

		p.OutputExprs = append(p.OutputExprs, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TDataStreamSink) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.OutputTupleId = &v
	}
	return nil
}

func (p *TDataStreamSink) ReadField6(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.Conjuncts = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if err := _elem.Read(iprot); err != nil {
			return err
		}

		p.Conjuncts = append(p.Conjuncts, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TDataStreamSink) ReadField7(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.RuntimeFilters = make([]*plannodes.TRuntimeFilterDesc, 0, size)
	for i := 0; i < size; i++ {
		_elem := plannodes.NewTRuntimeFilterDesc()
		if err := _elem.Read(iprot); err != nil {
			return err
		}

		p.RuntimeFilters = append(p.RuntimeFilters, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TDataStreamSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TDataStreamSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}
		if err = p.writeField5(oprot); err != nil {
			fieldId = 5
			goto WriteFieldError
		}
		if err = p.writeField6(oprot); err != nil {
			fieldId = 6
			goto WriteFieldError
		}
		if err = p.writeField7(oprot); err != nil {
			fieldId = 7
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TDataStreamSink) writeField1(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("dest_node_id", thrift.I32, 1); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI32(p.DestNodeId); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TDataStreamSink) writeField2(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("output_partition", thrift.STRUCT, 2); err != nil {
		goto WriteFieldBeginError
	}
	if err := p.OutputPartition.Write(oprot); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TDataStreamSink) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetIgnoreNotFound() {
		if err = oprot.WriteFieldBegin("ignore_not_found", thrift.BOOL, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.IgnoreNotFound); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TDataStreamSink) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetOutputExprs() {
		if err = oprot.WriteFieldBegin("output_exprs", thrift.LIST, 4); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.OutputExprs)); err != nil {
			return err
		}
		for _, v := range p.OutputExprs {
			if err := v.Write(oprot); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TDataStreamSink) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetOutputTupleId() {
		if err = oprot.WriteFieldBegin("output_tuple_id", thrift.I32, 5); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(*p.OutputTupleId); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 end error: ", p), err)
}

func (p *TDataStreamSink) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetConjuncts() {
		if err = oprot.WriteFieldBegin("conjuncts", thrift.LIST, 6); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Conjuncts)); err != nil {
			return err
		}
		for _, v := range p.Conjuncts {
			if err := v.Write(oprot); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 end error: ", p), err)
}

func (p *TDataStreamSink) writeField7(oprot thrift.TProtocol) (err error) {
	if p.IsSetRuntimeFilters() {
		if err = oprot.WriteFieldBegin("runtime_filters", thrift.LIST, 7); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RuntimeFilters)); err != nil {
			return err
		}
		for _, v := range p.RuntimeFilters {
			if err := v.Write(oprot); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 end error: ", p), err)
}

func (p *TDataStreamSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TDataStreamSink(%+v)", *p)
}

func (p *TDataStreamSink) DeepEqual(ano *TDataStreamSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.DestNodeId) {
		return false
	}
	if !p.Field2DeepEqual(ano.OutputPartition) {
		return false
	}
	if !p.Field3DeepEqual(ano.IgnoreNotFound) {
		return false
	}
	if !p.Field4DeepEqual(ano.OutputExprs) {
		return false
	}
	if !p.Field5DeepEqual(ano.OutputTupleId) {
		return false
	}
	if !p.Field6DeepEqual(ano.Conjuncts) {
		return false
	}
	if !p.Field7DeepEqual(ano.RuntimeFilters) {
		return false
	}
	return true
}

func (p *TDataStreamSink) Field1DeepEqual(src types.TPlanNodeId) bool {

	if p.DestNodeId != src {
		return false
	}
	return true
}
func (p *TDataStreamSink) Field2DeepEqual(src *partitions.TDataPartition) bool {

	if !p.OutputPartition.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataStreamSink) Field3DeepEqual(src *bool) bool {

	if p.IgnoreNotFound == src {
		return true
	} else if p.IgnoreNotFound == nil || src == nil {
		return false
	}
	if *p.IgnoreNotFound != *src {
		return false
	}
	return true
}
func (p *TDataStreamSink) Field4DeepEqual(src []*exprs.TExpr) bool {

	if len(p.OutputExprs) != len(src) {
		return false
	}
	for i, v := range p.OutputExprs {
		_src := src[i]
		if !v.DeepEqual(_src) {
			return false
		}
	}
	return true
}
func (p *TDataStreamSink) Field5DeepEqual(src *types.TTupleId) bool {

	if p.OutputTupleId == src {
		return true
	} else if p.OutputTupleId == nil || src == nil {
		return false
	}
	if *p.OutputTupleId != *src {
		return false
	}
	return true
}
func (p *TDataStreamSink) Field6DeepEqual(src []*exprs.TExpr) bool {

	if len(p.Conjuncts) != len(src) {
		return false
	}
	for i, v := range p.Conjuncts {
		_src := src[i]
		if !v.DeepEqual(_src) {
			return false
		}
	}
	return true
}
func (p *TDataStreamSink) Field7DeepEqual(src []*plannodes.TRuntimeFilterDesc) bool {

	if len(p.RuntimeFilters) != len(src) {
		return false
	}
	for i, v := range p.RuntimeFilters {
		_src := src[i]
		if !v.DeepEqual(_src) {
			return false
		}
	}
	return true
}

type TMultiCastDataStreamSink struct {
	Sinks        []*TDataStreamSink            `thrift:"sinks,1,optional" frugal:"1,optional,list<TDataStreamSink>" json:"sinks,omitempty"`
	Destinations [][]*TPlanFragmentDestination `thrift:"destinations,2,optional" frugal:"2,optional,list<list<TPlanFragmentDestination>>" json:"destinations,omitempty"`
}

func NewTMultiCastDataStreamSink() *TMultiCastDataStreamSink {
	return &TMultiCastDataStreamSink{}
}

func (p *TMultiCastDataStreamSink) InitDefault() {
	*p = TMultiCastDataStreamSink{}
}

var TMultiCastDataStreamSink_Sinks_DEFAULT []*TDataStreamSink

func (p *TMultiCastDataStreamSink) GetSinks() (v []*TDataStreamSink) {
	if !p.IsSetSinks() {
		return TMultiCastDataStreamSink_Sinks_DEFAULT
	}
	return p.Sinks
}

var TMultiCastDataStreamSink_Destinations_DEFAULT [][]*TPlanFragmentDestination

func (p *TMultiCastDataStreamSink) GetDestinations() (v [][]*TPlanFragmentDestination) {
	if !p.IsSetDestinations() {
		return TMultiCastDataStreamSink_Destinations_DEFAULT
	}
	return p.Destinations
}
func (p *TMultiCastDataStreamSink) SetSinks(val []*TDataStreamSink) {
	p.Sinks = val
}
func (p *TMultiCastDataStreamSink) SetDestinations(val [][]*TPlanFragmentDestination) {
	p.Destinations = val
}

var fieldIDToName_TMultiCastDataStreamSink = map[int16]string{
	1: "sinks",
	2: "destinations",
}

func (p *TMultiCastDataStreamSink) IsSetSinks() bool {
	return p.Sinks != nil
}

func (p *TMultiCastDataStreamSink) IsSetDestinations() bool {
	return p.Destinations != nil
}

func (p *TMultiCastDataStreamSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMultiCastDataStreamSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TMultiCastDataStreamSink) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.Sinks = make([]*TDataStreamSink, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTDataStreamSink()
		if err := _elem.Read(iprot); err != nil {
			return err
		}

		p.Sinks = append(p.Sinks, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TMultiCastDataStreamSink) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.Destinations = make([][]*TPlanFragmentDestination, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return err
		}
		_elem := make([]*TPlanFragmentDestination, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := NewTPlanFragmentDestination()
			if err := _elem1.Read(iprot); err != nil {
				return err
			}

			_elem = append(_elem, _elem1)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return err
		}

		p.Destinations = append(p.Destinations, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TMultiCastDataStreamSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TMultiCastDataStreamSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TMultiCastDataStreamSink) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetSinks() {
		if err = oprot.WriteFieldBegin("sinks", thrift.LIST, 1); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Sinks)); err != nil {
			return err
		}
		for _, v := range p.Sinks {
			if err := v.Write(oprot); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TMultiCastDataStreamSink) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetDestinations() {
		if err = oprot.WriteFieldBegin("destinations", thrift.LIST, 2); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Destinations)); err != nil {
			return err
		}
		for _, v := range p.Destinations {
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return err
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return err
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TMultiCastDataStreamSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TMultiCastDataStreamSink(%+v)", *p)
}

func (p *TMultiCastDataStreamSink) DeepEqual(ano *TMultiCastDataStreamSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.Sinks) {
		return false
	}
	if !p.Field2DeepEqual(ano.Destinations) {
		return false
	}
	return true
}

func (p *TMultiCastDataStreamSink) Field1DeepEqual(src []*TDataStreamSink) bool {

	if len(p.Sinks) != len(src) {
		return false
	}
	for i, v := range p.Sinks {
		_src := src[i]
		if !v.DeepEqual(_src) {
			return false
		}
	}
	return true
}
func (p *TMultiCastDataStreamSink) Field2DeepEqual(src [][]*TPlanFragmentDestination) bool {

	if len(p.Destinations) != len(src) {
		return false
	}
	for i, v := range p.Destinations {
		_src := src[i]
		if len(v) != len(_src) {
			return false
		}
		for i, v := range v {
			_src1 := _src[i]
			if !v.DeepEqual(_src1) {
				return false
			}
		}
	}
	return true
}

type TFetchOption struct {
	UseTwoPhaseFetch *bool                       `thrift:"use_two_phase_fetch,1,optional" frugal:"1,optional,bool" json:"use_two_phase_fetch,omitempty"`
	NodesInfo        *descriptors.TPaloNodesInfo `thrift:"nodes_info,2,optional" frugal:"2,optional,descriptors.TPaloNodesInfo" json:"nodes_info,omitempty"`
	FetchRowStore    *bool                       `thrift:"fetch_row_store,3,optional" frugal:"3,optional,bool" json:"fetch_row_store,omitempty"`
	ColumnDesc       []*descriptors.TColumn      `thrift:"column_desc,4,optional" frugal:"4,optional,list<descriptors.TColumn>" json:"column_desc,omitempty"`
}

func NewTFetchOption() *TFetchOption {
	return &TFetchOption{}
}

func (p *TFetchOption) InitDefault() {
	*p = TFetchOption{}
}

var TFetchOption_UseTwoPhaseFetch_DEFAULT bool

func (p *TFetchOption) GetUseTwoPhaseFetch() (v bool) {
	if !p.IsSetUseTwoPhaseFetch() {
		return TFetchOption_UseTwoPhaseFetch_DEFAULT
	}
	return *p.UseTwoPhaseFetch
}

var TFetchOption_NodesInfo_DEFAULT *descriptors.TPaloNodesInfo

func (p *TFetchOption) GetNodesInfo() (v *descriptors.TPaloNodesInfo) {
	if !p.IsSetNodesInfo() {
		return TFetchOption_NodesInfo_DEFAULT
	}
	return p.NodesInfo
}

var TFetchOption_FetchRowStore_DEFAULT bool

func (p *TFetchOption) GetFetchRowStore() (v bool) {
	if !p.IsSetFetchRowStore() {
		return TFetchOption_FetchRowStore_DEFAULT
	}
	return *p.FetchRowStore
}

var TFetchOption_ColumnDesc_DEFAULT []*descriptors.TColumn

func (p *TFetchOption) GetColumnDesc() (v []*descriptors.TColumn) {
	if !p.IsSetColumnDesc() {
		return TFetchOption_ColumnDesc_DEFAULT
	}
	return p.ColumnDesc
}
func (p *TFetchOption) SetUseTwoPhaseFetch(val *bool) {
	p.UseTwoPhaseFetch = val
}
func (p *TFetchOption) SetNodesInfo(val *descriptors.TPaloNodesInfo) {
	p.NodesInfo = val
}
func (p *TFetchOption) SetFetchRowStore(val *bool) {
	p.FetchRowStore = val
}
func (p *TFetchOption) SetColumnDesc(val []*descriptors.TColumn) {
	p.ColumnDesc = val
}

var fieldIDToName_TFetchOption = map[int16]string{
	1: "use_two_phase_fetch",
	2: "nodes_info",
	3: "fetch_row_store",
	4: "column_desc",
}

func (p *TFetchOption) IsSetUseTwoPhaseFetch() bool {
	return p.UseTwoPhaseFetch != nil
}

func (p *TFetchOption) IsSetNodesInfo() bool {
	return p.NodesInfo != nil
}

func (p *TFetchOption) IsSetFetchRowStore() bool {
	return p.FetchRowStore != nil
}

func (p *TFetchOption) IsSetColumnDesc() bool {
	return p.ColumnDesc != nil
}

func (p *TFetchOption) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFetchOption[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFetchOption) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.UseTwoPhaseFetch = &v
	}
	return nil
}

func (p *TFetchOption) ReadField2(iprot thrift.TProtocol) error {
	p.NodesInfo = descriptors.NewTPaloNodesInfo()
	if err := p.NodesInfo.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TFetchOption) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.FetchRowStore = &v
	}
	return nil
}

func (p *TFetchOption) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.ColumnDesc = make([]*descriptors.TColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem := descriptors.NewTColumn()
		if err := _elem.Read(iprot); err != nil {
			return err
		}

		p.ColumnDesc = append(p.ColumnDesc, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TFetchOption) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TFetchOption"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TFetchOption) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUseTwoPhaseFetch() {
		if err = oprot.WriteFieldBegin("use_two_phase_fetch", thrift.BOOL, 1); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.UseTwoPhaseFetch); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TFetchOption) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetNodesInfo() {
		if err = oprot.WriteFieldBegin("nodes_info", thrift.STRUCT, 2); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.NodesInfo.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TFetchOption) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetFetchRowStore() {
		if err = oprot.WriteFieldBegin("fetch_row_store", thrift.BOOL, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.FetchRowStore); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TFetchOption) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnDesc() {
		if err = oprot.WriteFieldBegin("column_desc", thrift.LIST, 4); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnDesc)); err != nil {
			return err
		}
		for _, v := range p.ColumnDesc {
			if err := v.Write(oprot); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TFetchOption) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TFetchOption(%+v)", *p)
}

func (p *TFetchOption) DeepEqual(ano *TFetchOption) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.UseTwoPhaseFetch) {
		return false
	}
	if !p.Field2DeepEqual(ano.NodesInfo) {
		return false
	}
	if !p.Field3DeepEqual(ano.FetchRowStore) {
		return false
	}
	if !p.Field4DeepEqual(ano.ColumnDesc) {
		return false
	}
	return true
}

func (p *TFetchOption) Field1DeepEqual(src *bool) bool {

	if p.UseTwoPhaseFetch == src {
		return true
	} else if p.UseTwoPhaseFetch == nil || src == nil {
		return false
	}
	if *p.UseTwoPhaseFetch != *src {
		return false
	}
	return true
}
func (p *TFetchOption) Field2DeepEqual(src *descriptors.TPaloNodesInfo) bool {

	if !p.NodesInfo.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TFetchOption) Field3DeepEqual(src *bool) bool {

	if p.FetchRowStore == src {
		return true
	} else if p.FetchRowStore == nil || src == nil {
		return false
	}
	if *p.FetchRowStore != *src {
		return false
	}
	return true
}
func (p *TFetchOption) Field4DeepEqual(src []*descriptors.TColumn) bool {

	if len(p.ColumnDesc) != len(src) {
		return false
	}
	for i, v := range p.ColumnDesc {
		_src := src[i]
		if !v.DeepEqual(_src) {
			return false
		}
	}
	return true
}

type TResultSink struct {
	Type        *TResultSinkType        `thrift:"type,1,optional" frugal:"1,optional,TResultSinkType" json:"type,omitempty"`
	FileOptions *TResultFileSinkOptions `thrift:"file_options,2,optional" frugal:"2,optional,TResultFileSinkOptions" json:"file_options,omitempty"`
	FetchOption *TFetchOption           `thrift:"fetch_option,3,optional" frugal:"3,optional,TFetchOption" json:"fetch_option,omitempty"`
}

func NewTResultSink() *TResultSink {
	return &TResultSink{}
}

func (p *TResultSink) InitDefault() {
	*p = TResultSink{}
}

var TResultSink_Type_DEFAULT TResultSinkType

func (p *TResultSink) GetType() (v TResultSinkType) {
	if !p.IsSetType() {
		return TResultSink_Type_DEFAULT
	}
	return *p.Type
}

var TResultSink_FileOptions_DEFAULT *TResultFileSinkOptions

func (p *TResultSink) GetFileOptions() (v *TResultFileSinkOptions) {
	if !p.IsSetFileOptions() {
		return TResultSink_FileOptions_DEFAULT
	}
	return p.FileOptions
}

var TResultSink_FetchOption_DEFAULT *TFetchOption

func (p *TResultSink) GetFetchOption() (v *TFetchOption) {
	if !p.IsSetFetchOption() {
		return TResultSink_FetchOption_DEFAULT
	}
	return p.FetchOption
}
func (p *TResultSink) SetType(val *TResultSinkType) {
	p.Type = val
}
func (p *TResultSink) SetFileOptions(val *TResultFileSinkOptions) {
	p.FileOptions = val
}
func (p *TResultSink) SetFetchOption(val *TFetchOption) {
	p.FetchOption = val
}

var fieldIDToName_TResultSink = map[int16]string{
	1: "type",
	2: "file_options",
	3: "fetch_option",
}

func (p *TResultSink) IsSetType() bool {
	return p.Type != nil
}

func (p *TResultSink) IsSetFileOptions() bool {
	return p.FileOptions != nil
}

func (p *TResultSink) IsSetFetchOption() bool {
	return p.FetchOption != nil
}

func (p *TResultSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TResultSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TResultSink) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		tmp := TResultSinkType(v)
		p.Type = &tmp
	}
	return nil
}

func (p *TResultSink) ReadField2(iprot thrift.TProtocol) error {
	p.FileOptions = NewTResultFileSinkOptions()
	if err := p.FileOptions.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TResultSink) ReadField3(iprot thrift.TProtocol) error {
	p.FetchOption = NewTFetchOption()
	if err := p.FetchOption.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TResultSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TResultSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TResultSink) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetType() {
		if err = oprot.WriteFieldBegin("type", thrift.I32, 1); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(int32(*p.Type)); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TResultSink) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetFileOptions() {
		if err = oprot.WriteFieldBegin("file_options", thrift.STRUCT, 2); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.FileOptions.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TResultSink) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetFetchOption() {
		if err = oprot.WriteFieldBegin("fetch_option", thrift.STRUCT, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.FetchOption.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TResultSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TResultSink(%+v)", *p)
}

func (p *TResultSink) DeepEqual(ano *TResultSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.Type) {
		return false
	}
	if !p.Field2DeepEqual(ano.FileOptions) {
		return false
	}
	if !p.Field3DeepEqual(ano.FetchOption) {
		return false
	}
	return true
}

func (p *TResultSink) Field1DeepEqual(src *TResultSinkType) bool {

	if p.Type == src {
		return true
	} else if p.Type == nil || src == nil {
		return false
	}
	if *p.Type != *src {
		return false
	}
	return true
}
func (p *TResultSink) Field2DeepEqual(src *TResultFileSinkOptions) bool {

	if !p.FileOptions.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TResultSink) Field3DeepEqual(src *TFetchOption) bool {

	if !p.FetchOption.DeepEqual(src) {
		return false
	}
	return true
}

type TResultFileSink struct {
	FileOptions        *TResultFileSinkOptions    `thrift:"file_options,1,optional" frugal:"1,optional,TResultFileSinkOptions" json:"file_options,omitempty"`
	StorageBackendType *types.TStorageBackendType `thrift:"storage_backend_type,2,optional" frugal:"2,optional,TStorageBackendType" json:"storage_backend_type,omitempty"`
	DestNodeId         *types.TPlanNodeId         `thrift:"dest_node_id,3,optional" frugal:"3,optional,i32" json:"dest_node_id,omitempty"`
	OutputTupleId      *types.TTupleId            `thrift:"output_tuple_id,4,optional" frugal:"4,optional,i32" json:"output_tuple_id,omitempty"`
	Header             *string                    `thrift:"header,5,optional" frugal:"5,optional,string" json:"header,omitempty"`
	HeaderType         *string                    `thrift:"header_type,6,optional" frugal:"6,optional,string" json:"header_type,omitempty"`
}

func NewTResultFileSink() *TResultFileSink {
	return &TResultFileSink{}
}

func (p *TResultFileSink) InitDefault() {
	*p = TResultFileSink{}
}

var TResultFileSink_FileOptions_DEFAULT *TResultFileSinkOptions

func (p *TResultFileSink) GetFileOptions() (v *TResultFileSinkOptions) {
	if !p.IsSetFileOptions() {
		return TResultFileSink_FileOptions_DEFAULT
	}
	return p.FileOptions
}

var TResultFileSink_StorageBackendType_DEFAULT types.TStorageBackendType

func (p *TResultFileSink) GetStorageBackendType() (v types.TStorageBackendType) {
	if !p.IsSetStorageBackendType() {
		return TResultFileSink_StorageBackendType_DEFAULT
	}
	return *p.StorageBackendType
}

var TResultFileSink_DestNodeId_DEFAULT types.TPlanNodeId

func (p *TResultFileSink) GetDestNodeId() (v types.TPlanNodeId) {
	if !p.IsSetDestNodeId() {
		return TResultFileSink_DestNodeId_DEFAULT
	}
	return *p.DestNodeId
}

var TResultFileSink_OutputTupleId_DEFAULT types.TTupleId

func (p *TResultFileSink) GetOutputTupleId() (v types.TTupleId) {
	if !p.IsSetOutputTupleId() {
		return TResultFileSink_OutputTupleId_DEFAULT
	}
	return *p.OutputTupleId
}

var TResultFileSink_Header_DEFAULT string

func (p *TResultFileSink) GetHeader() (v string) {
	if !p.IsSetHeader() {
		return TResultFileSink_Header_DEFAULT
	}
	return *p.Header
}

var TResultFileSink_HeaderType_DEFAULT string

func (p *TResultFileSink) GetHeaderType() (v string) {
	if !p.IsSetHeaderType() {
		return TResultFileSink_HeaderType_DEFAULT
	}
	return *p.HeaderType
}
func (p *TResultFileSink) SetFileOptions(val *TResultFileSinkOptions) {
	p.FileOptions = val
}
func (p *TResultFileSink) SetStorageBackendType(val *types.TStorageBackendType) {
	p.StorageBackendType = val
}
func (p *TResultFileSink) SetDestNodeId(val *types.TPlanNodeId) {
	p.DestNodeId = val
}
func (p *TResultFileSink) SetOutputTupleId(val *types.TTupleId) {
	p.OutputTupleId = val
}
func (p *TResultFileSink) SetHeader(val *string) {
	p.Header = val
}
func (p *TResultFileSink) SetHeaderType(val *string) {
	p.HeaderType = val
}

var fieldIDToName_TResultFileSink = map[int16]string{
	1: "file_options",
	2: "storage_backend_type",
	3: "dest_node_id",
	4: "output_tuple_id",
	5: "header",
	6: "header_type",
}

func (p *TResultFileSink) IsSetFileOptions() bool {
	return p.FileOptions != nil
}

func (p *TResultFileSink) IsSetStorageBackendType() bool {
	return p.StorageBackendType != nil
}

func (p *TResultFileSink) IsSetDestNodeId() bool {
	return p.DestNodeId != nil
}

func (p *TResultFileSink) IsSetOutputTupleId() bool {
	return p.OutputTupleId != nil
}

func (p *TResultFileSink) IsSetHeader() bool {
	return p.Header != nil
}

func (p *TResultFileSink) IsSetHeaderType() bool {
	return p.HeaderType != nil
}

func (p *TResultFileSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField5(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField6(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TResultFileSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TResultFileSink) ReadField1(iprot thrift.TProtocol) error {
	p.FileOptions = NewTResultFileSinkOptions()
	if err := p.FileOptions.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TResultFileSink) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		tmp := types.TStorageBackendType(v)
		p.StorageBackendType = &tmp
	}
	return nil
}

func (p *TResultFileSink) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.DestNodeId = &v
	}
	return nil
}

func (p *TResultFileSink) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.OutputTupleId = &v
	}
	return nil
}

func (p *TResultFileSink) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.Header = &v
	}
	return nil
}

func (p *TResultFileSink) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.HeaderType = &v
	}
	return nil
}

func (p *TResultFileSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TResultFileSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}
		if err = p.writeField5(oprot); err != nil {
			fieldId = 5
			goto WriteFieldError
		}
		if err = p.writeField6(oprot); err != nil {
			fieldId = 6
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TResultFileSink) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetFileOptions() {
		if err = oprot.WriteFieldBegin("file_options", thrift.STRUCT, 1); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.FileOptions.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TResultFileSink) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetStorageBackendType() {
		if err = oprot.WriteFieldBegin("storage_backend_type", thrift.I32, 2); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(int32(*p.StorageBackendType)); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TResultFileSink) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetDestNodeId() {
		if err = oprot.WriteFieldBegin("dest_node_id", thrift.I32, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(*p.DestNodeId); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TResultFileSink) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetOutputTupleId() {
		if err = oprot.WriteFieldBegin("output_tuple_id", thrift.I32, 4); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(*p.OutputTupleId); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TResultFileSink) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetHeader() {
		if err = oprot.WriteFieldBegin("header", thrift.STRING, 5); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.Header); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 end error: ", p), err)
}

func (p *TResultFileSink) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetHeaderType() {
		if err = oprot.WriteFieldBegin("header_type", thrift.STRING, 6); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.HeaderType); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 end error: ", p), err)
}

func (p *TResultFileSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TResultFileSink(%+v)", *p)
}

func (p *TResultFileSink) DeepEqual(ano *TResultFileSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.FileOptions) {
		return false
	}
	if !p.Field2DeepEqual(ano.StorageBackendType) {
		return false
	}
	if !p.Field3DeepEqual(ano.DestNodeId) {
		return false
	}
	if !p.Field4DeepEqual(ano.OutputTupleId) {
		return false
	}
	if !p.Field5DeepEqual(ano.Header) {
		return false
	}
	if !p.Field6DeepEqual(ano.HeaderType) {
		return false
	}
	return true
}

func (p *TResultFileSink) Field1DeepEqual(src *TResultFileSinkOptions) bool {

	if !p.FileOptions.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TResultFileSink) Field2DeepEqual(src *types.TStorageBackendType) bool {

	if p.StorageBackendType == src {
		return true
	} else if p.StorageBackendType == nil || src == nil {
		return false
	}
	if *p.StorageBackendType != *src {
		return false
	}
	return true
}
func (p *TResultFileSink) Field3DeepEqual(src *types.TPlanNodeId) bool {

	if p.DestNodeId == src {
		return true
	} else if p.DestNodeId == nil || src == nil {
		return false
	}
	if *p.DestNodeId != *src {
		return false
	}
	return true
}
func (p *TResultFileSink) Field4DeepEqual(src *types.TTupleId) bool {

	if p.OutputTupleId == src {
		return true
	} else if p.OutputTupleId == nil || src == nil {
		return false
	}
	if *p.OutputTupleId != *src {
		return false
	}
	return true
}
func (p *TResultFileSink) Field5DeepEqual(src *string) bool {

	if p.Header == src {
		return true
	} else if p.Header == nil || src == nil {
		return false
	}
	if strings.Compare(*p.Header, *src) != 0 {
		return false
	}
	return true
}
func (p *TResultFileSink) Field6DeepEqual(src *string) bool {

	if p.HeaderType == src {
		return true
	} else if p.HeaderType == nil || src == nil {
		return false
	}
	if strings.Compare(*p.HeaderType, *src) != 0 {
		return false
	}
	return true
}

type TMysqlTableSink struct {
	Host    string `thrift:"host,1,required" frugal:"1,required,string" json:"host"`
	Port    int32  `thrift:"port,2,required" frugal:"2,required,i32" json:"port"`
	User    string `thrift:"user,3,required" frugal:"3,required,string" json:"user"`
	Passwd  string `thrift:"passwd,4,required" frugal:"4,required,string" json:"passwd"`
	Db      string `thrift:"db,5,required" frugal:"5,required,string" json:"db"`
	Table   string `thrift:"table,6,required" frugal:"6,required,string" json:"table"`
	Charset string `thrift:"charset,7,required" frugal:"7,required,string" json:"charset"`
}

func NewTMysqlTableSink() *TMysqlTableSink {
	return &TMysqlTableSink{}
}

func (p *TMysqlTableSink) InitDefault() {
	*p = TMysqlTableSink{}
}

func (p *TMysqlTableSink) GetHost() (v string) {
	return p.Host
}

func (p *TMysqlTableSink) GetPort() (v int32) {
	return p.Port
}

func (p *TMysqlTableSink) GetUser() (v string) {
	return p.User
}

func (p *TMysqlTableSink) GetPasswd() (v string) {
	return p.Passwd
}

func (p *TMysqlTableSink) GetDb() (v string) {
	return p.Db
}

func (p *TMysqlTableSink) GetTable() (v string) {
	return p.Table
}

func (p *TMysqlTableSink) GetCharset() (v string) {
	return p.Charset
}
func (p *TMysqlTableSink) SetHost(val string) {
	p.Host = val
}
func (p *TMysqlTableSink) SetPort(val int32) {
	p.Port = val
}
func (p *TMysqlTableSink) SetUser(val string) {
	p.User = val
}
func (p *TMysqlTableSink) SetPasswd(val string) {
	p.Passwd = val
}
func (p *TMysqlTableSink) SetDb(val string) {
	p.Db = val
}
func (p *TMysqlTableSink) SetTable(val string) {
	p.Table = val
}
func (p *TMysqlTableSink) SetCharset(val string) {
	p.Charset = val
}

var fieldIDToName_TMysqlTableSink = map[int16]string{
	1: "host",
	2: "port",
	3: "user",
	4: "passwd",
	5: "db",
	6: "table",
	7: "charset",
}

func (p *TMysqlTableSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16
	var issetHost bool = false
	var issetPort bool = false
	var issetUser bool = false
	var issetPasswd bool = false
	var issetDb bool = false
	var issetTable bool = false
	var issetCharset bool = false

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
				issetHost = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
				issetPort = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
				issetUser = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
				issetPasswd = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField5(iprot); err != nil {
					goto ReadFieldError
				}
				issetDb = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField6(iprot); err != nil {
					goto ReadFieldError
				}
				issetTable = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField7(iprot); err != nil {
					goto ReadFieldError
				}
				issetCharset = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	if !issetHost {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetPort {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetUser {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetPasswd {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetDb {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetTable {
		fieldId = 6
		goto RequiredFieldNotSetError
	}

	if !issetCharset {
		fieldId = 7
		goto RequiredFieldNotSetError
	}
	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMysqlTableSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TMysqlTableSink[fieldId]))
}

func (p *TMysqlTableSink) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.Host = v
	}
	return nil
}

func (p *TMysqlTableSink) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.Port = v
	}
	return nil
}

func (p *TMysqlTableSink) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.User = v
	}
	return nil
}

func (p *TMysqlTableSink) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.Passwd = v
	}
	return nil
}

func (p *TMysqlTableSink) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.Db = v
	}
	return nil
}

func (p *TMysqlTableSink) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.Table = v
	}
	return nil
}

func (p *TMysqlTableSink) ReadField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.Charset = v
	}
	return nil
}

func (p *TMysqlTableSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TMysqlTableSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}
		if err = p.writeField5(oprot); err != nil {
			fieldId = 5
			goto WriteFieldError
		}
		if err = p.writeField6(oprot); err != nil {
			fieldId = 6
			goto WriteFieldError
		}
		if err = p.writeField7(oprot); err != nil {
			fieldId = 7
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TMysqlTableSink) writeField1(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("host", thrift.STRING, 1); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.Host); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TMysqlTableSink) writeField2(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("port", thrift.I32, 2); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI32(p.Port); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TMysqlTableSink) writeField3(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("user", thrift.STRING, 3); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.User); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TMysqlTableSink) writeField4(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("passwd", thrift.STRING, 4); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.Passwd); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TMysqlTableSink) writeField5(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("db", thrift.STRING, 5); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.Db); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 end error: ", p), err)
}

func (p *TMysqlTableSink) writeField6(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("table", thrift.STRING, 6); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.Table); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 end error: ", p), err)
}

func (p *TMysqlTableSink) writeField7(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("charset", thrift.STRING, 7); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.Charset); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 end error: ", p), err)
}

func (p *TMysqlTableSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TMysqlTableSink(%+v)", *p)
}

func (p *TMysqlTableSink) DeepEqual(ano *TMysqlTableSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.Host) {
		return false
	}
	if !p.Field2DeepEqual(ano.Port) {
		return false
	}
	if !p.Field3DeepEqual(ano.User) {
		return false
	}
	if !p.Field4DeepEqual(ano.Passwd) {
		return false
	}
	if !p.Field5DeepEqual(ano.Db) {
		return false
	}
	if !p.Field6DeepEqual(ano.Table) {
		return false
	}
	if !p.Field7DeepEqual(ano.Charset) {
		return false
	}
	return true
}

func (p *TMysqlTableSink) Field1DeepEqual(src string) bool {

	if strings.Compare(p.Host, src) != 0 {
		return false
	}
	return true
}
func (p *TMysqlTableSink) Field2DeepEqual(src int32) bool {

	if p.Port != src {
		return false
	}
	return true
}
func (p *TMysqlTableSink) Field3DeepEqual(src string) bool {

	if strings.Compare(p.User, src) != 0 {
		return false
	}
	return true
}
func (p *TMysqlTableSink) Field4DeepEqual(src string) bool {

	if strings.Compare(p.Passwd, src) != 0 {
		return false
	}
	return true
}
func (p *TMysqlTableSink) Field5DeepEqual(src string) bool {

	if strings.Compare(p.Db, src) != 0 {
		return false
	}
	return true
}
func (p *TMysqlTableSink) Field6DeepEqual(src string) bool {

	if strings.Compare(p.Table, src) != 0 {
		return false
	}
	return true
}
func (p *TMysqlTableSink) Field7DeepEqual(src string) bool {

	if strings.Compare(p.Charset, src) != 0 {
		return false
	}
	return true
}

type TOdbcTableSink struct {
	ConnectString  *string `thrift:"connect_string,1,optional" frugal:"1,optional,string" json:"connect_string,omitempty"`
	Table          *string `thrift:"table,2,optional" frugal:"2,optional,string" json:"table,omitempty"`
	UseTransaction *bool   `thrift:"use_transaction,3,optional" frugal:"3,optional,bool" json:"use_transaction,omitempty"`
}

func NewTOdbcTableSink() *TOdbcTableSink {
	return &TOdbcTableSink{}
}

func (p *TOdbcTableSink) InitDefault() {
	*p = TOdbcTableSink{}
}

var TOdbcTableSink_ConnectString_DEFAULT string

func (p *TOdbcTableSink) GetConnectString() (v string) {
	if !p.IsSetConnectString() {
		return TOdbcTableSink_ConnectString_DEFAULT
	}
	return *p.ConnectString
}

var TOdbcTableSink_Table_DEFAULT string

func (p *TOdbcTableSink) GetTable() (v string) {
	if !p.IsSetTable() {
		return TOdbcTableSink_Table_DEFAULT
	}
	return *p.Table
}

var TOdbcTableSink_UseTransaction_DEFAULT bool

func (p *TOdbcTableSink) GetUseTransaction() (v bool) {
	if !p.IsSetUseTransaction() {
		return TOdbcTableSink_UseTransaction_DEFAULT
	}
	return *p.UseTransaction
}
func (p *TOdbcTableSink) SetConnectString(val *string) {
	p.ConnectString = val
}
func (p *TOdbcTableSink) SetTable(val *string) {
	p.Table = val
}
func (p *TOdbcTableSink) SetUseTransaction(val *bool) {
	p.UseTransaction = val
}

var fieldIDToName_TOdbcTableSink = map[int16]string{
	1: "connect_string",
	2: "table",
	3: "use_transaction",
}

func (p *TOdbcTableSink) IsSetConnectString() bool {
	return p.ConnectString != nil
}

func (p *TOdbcTableSink) IsSetTable() bool {
	return p.Table != nil
}

func (p *TOdbcTableSink) IsSetUseTransaction() bool {
	return p.UseTransaction != nil
}

func (p *TOdbcTableSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOdbcTableSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TOdbcTableSink) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.ConnectString = &v
	}
	return nil
}

func (p *TOdbcTableSink) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.Table = &v
	}
	return nil
}

func (p *TOdbcTableSink) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.UseTransaction = &v
	}
	return nil
}

func (p *TOdbcTableSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TOdbcTableSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TOdbcTableSink) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetConnectString() {
		if err = oprot.WriteFieldBegin("connect_string", thrift.STRING, 1); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.ConnectString); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TOdbcTableSink) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetTable() {
		if err = oprot.WriteFieldBegin("table", thrift.STRING, 2); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.Table); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TOdbcTableSink) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetUseTransaction() {
		if err = oprot.WriteFieldBegin("use_transaction", thrift.BOOL, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.UseTransaction); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TOdbcTableSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TOdbcTableSink(%+v)", *p)
}

func (p *TOdbcTableSink) DeepEqual(ano *TOdbcTableSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.ConnectString) {
		return false
	}
	if !p.Field2DeepEqual(ano.Table) {
		return false
	}
	if !p.Field3DeepEqual(ano.UseTransaction) {
		return false
	}
	return true
}

func (p *TOdbcTableSink) Field1DeepEqual(src *string) bool {

	if p.ConnectString == src {
		return true
	} else if p.ConnectString == nil || src == nil {
		return false
	}
	if strings.Compare(*p.ConnectString, *src) != 0 {
		return false
	}
	return true
}
func (p *TOdbcTableSink) Field2DeepEqual(src *string) bool {

	if p.Table == src {
		return true
	} else if p.Table == nil || src == nil {
		return false
	}
	if strings.Compare(*p.Table, *src) != 0 {
		return false
	}
	return true
}
func (p *TOdbcTableSink) Field3DeepEqual(src *bool) bool {

	if p.UseTransaction == src {
		return true
	} else if p.UseTransaction == nil || src == nil {
		return false
	}
	if *p.UseTransaction != *src {
		return false
	}
	return true
}

type TJdbcTableSink struct {
	JdbcTable      *descriptors.TJdbcTable `thrift:"jdbc_table,1,optional" frugal:"1,optional,descriptors.TJdbcTable" json:"jdbc_table,omitempty"`
	UseTransaction *bool                   `thrift:"use_transaction,2,optional" frugal:"2,optional,bool" json:"use_transaction,omitempty"`
	TableType      *types.TOdbcTableType   `thrift:"table_type,3,optional" frugal:"3,optional,TOdbcTableType" json:"table_type,omitempty"`
	InsertSql      *string                 `thrift:"insert_sql,4,optional" frugal:"4,optional,string" json:"insert_sql,omitempty"`
}

func NewTJdbcTableSink() *TJdbcTableSink {
	return &TJdbcTableSink{}
}

func (p *TJdbcTableSink) InitDefault() {
	*p = TJdbcTableSink{}
}

var TJdbcTableSink_JdbcTable_DEFAULT *descriptors.TJdbcTable

func (p *TJdbcTableSink) GetJdbcTable() (v *descriptors.TJdbcTable) {
	if !p.IsSetJdbcTable() {
		return TJdbcTableSink_JdbcTable_DEFAULT
	}
	return p.JdbcTable
}

var TJdbcTableSink_UseTransaction_DEFAULT bool

func (p *TJdbcTableSink) GetUseTransaction() (v bool) {
	if !p.IsSetUseTransaction() {
		return TJdbcTableSink_UseTransaction_DEFAULT
	}
	return *p.UseTransaction
}

var TJdbcTableSink_TableType_DEFAULT types.TOdbcTableType

func (p *TJdbcTableSink) GetTableType() (v types.TOdbcTableType) {
	if !p.IsSetTableType() {
		return TJdbcTableSink_TableType_DEFAULT
	}
	return *p.TableType
}

var TJdbcTableSink_InsertSql_DEFAULT string

func (p *TJdbcTableSink) GetInsertSql() (v string) {
	if !p.IsSetInsertSql() {
		return TJdbcTableSink_InsertSql_DEFAULT
	}
	return *p.InsertSql
}
func (p *TJdbcTableSink) SetJdbcTable(val *descriptors.TJdbcTable) {
	p.JdbcTable = val
}
func (p *TJdbcTableSink) SetUseTransaction(val *bool) {
	p.UseTransaction = val
}
func (p *TJdbcTableSink) SetTableType(val *types.TOdbcTableType) {
	p.TableType = val
}
func (p *TJdbcTableSink) SetInsertSql(val *string) {
	p.InsertSql = val
}

var fieldIDToName_TJdbcTableSink = map[int16]string{
	1: "jdbc_table",
	2: "use_transaction",
	3: "table_type",
	4: "insert_sql",
}

func (p *TJdbcTableSink) IsSetJdbcTable() bool {
	return p.JdbcTable != nil
}

func (p *TJdbcTableSink) IsSetUseTransaction() bool {
	return p.UseTransaction != nil
}

func (p *TJdbcTableSink) IsSetTableType() bool {
	return p.TableType != nil
}

func (p *TJdbcTableSink) IsSetInsertSql() bool {
	return p.InsertSql != nil
}

func (p *TJdbcTableSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TJdbcTableSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TJdbcTableSink) ReadField1(iprot thrift.TProtocol) error {
	p.JdbcTable = descriptors.NewTJdbcTable()
	if err := p.JdbcTable.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TJdbcTableSink) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.UseTransaction = &v
	}
	return nil
}

func (p *TJdbcTableSink) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		tmp := types.TOdbcTableType(v)
		p.TableType = &tmp
	}
	return nil
}

func (p *TJdbcTableSink) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.InsertSql = &v
	}
	return nil
}

func (p *TJdbcTableSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TJdbcTableSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TJdbcTableSink) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetJdbcTable() {
		if err = oprot.WriteFieldBegin("jdbc_table", thrift.STRUCT, 1); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.JdbcTable.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TJdbcTableSink) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUseTransaction() {
		if err = oprot.WriteFieldBegin("use_transaction", thrift.BOOL, 2); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.UseTransaction); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TJdbcTableSink) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTableType() {
		if err = oprot.WriteFieldBegin("table_type", thrift.I32, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(int32(*p.TableType)); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TJdbcTableSink) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetInsertSql() {
		if err = oprot.WriteFieldBegin("insert_sql", thrift.STRING, 4); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.InsertSql); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TJdbcTableSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TJdbcTableSink(%+v)", *p)
}

func (p *TJdbcTableSink) DeepEqual(ano *TJdbcTableSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.JdbcTable) {
		return false
	}
	if !p.Field2DeepEqual(ano.UseTransaction) {
		return false
	}
	if !p.Field3DeepEqual(ano.TableType) {
		return false
	}
	if !p.Field4DeepEqual(ano.InsertSql) {
		return false
	}
	return true
}

func (p *TJdbcTableSink) Field1DeepEqual(src *descriptors.TJdbcTable) bool {

	if !p.JdbcTable.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TJdbcTableSink) Field2DeepEqual(src *bool) bool {

	if p.UseTransaction == src {
		return true
	} else if p.UseTransaction == nil || src == nil {
		return false
	}
	if *p.UseTransaction != *src {
		return false
	}
	return true
}
func (p *TJdbcTableSink) Field3DeepEqual(src *types.TOdbcTableType) bool {

	if p.TableType == src {
		return true
	} else if p.TableType == nil || src == nil {
		return false
	}
	if *p.TableType != *src {
		return false
	}
	return true
}
func (p *TJdbcTableSink) Field4DeepEqual(src *string) bool {

	if p.InsertSql == src {
		return true
	} else if p.InsertSql == nil || src == nil {
		return false
	}
	if strings.Compare(*p.InsertSql, *src) != 0 {
		return false
	}
	return true
}

type TExportSink struct {
	FileType        types.TFileType          `thrift:"file_type,1,required" frugal:"1,required,TFileType" json:"file_type"`
	ExportPath      string                   `thrift:"export_path,2,required" frugal:"2,required,string" json:"export_path"`
	ColumnSeparator string                   `thrift:"column_separator,3,required" frugal:"3,required,string" json:"column_separator"`
	LineDelimiter   string                   `thrift:"line_delimiter,4,required" frugal:"4,required,string" json:"line_delimiter"`
	BrokerAddresses []*types.TNetworkAddress `thrift:"broker_addresses,5,optional" frugal:"5,optional,list<types.TNetworkAddress>" json:"broker_addresses,omitempty"`
	Properties      map[string]string        `thrift:"properties,6,optional" frugal:"6,optional,map<string:string>" json:"properties,omitempty"`
	Header          *string                  `thrift:"header,7,optional" frugal:"7,optional,string" json:"header,omitempty"`
}

func NewTExportSink() *TExportSink {
	return &TExportSink{}
}

func (p *TExportSink) InitDefault() {
	*p = TExportSink{}
}

func (p *TExportSink) GetFileType() (v types.TFileType) {
	return p.FileType
}

func (p *TExportSink) GetExportPath() (v string) {
	return p.ExportPath
}

func (p *TExportSink) GetColumnSeparator() (v string) {
	return p.ColumnSeparator
}

func (p *TExportSink) GetLineDelimiter() (v string) {
	return p.LineDelimiter
}

var TExportSink_BrokerAddresses_DEFAULT []*types.TNetworkAddress

func (p *TExportSink) GetBrokerAddresses() (v []*types.TNetworkAddress) {
	if !p.IsSetBrokerAddresses() {
		return TExportSink_BrokerAddresses_DEFAULT
	}
	return p.BrokerAddresses
}

var TExportSink_Properties_DEFAULT map[string]string

func (p *TExportSink) GetProperties() (v map[string]string) {
	if !p.IsSetProperties() {
		return TExportSink_Properties_DEFAULT
	}
	return p.Properties
}

var TExportSink_Header_DEFAULT string

func (p *TExportSink) GetHeader() (v string) {
	if !p.IsSetHeader() {
		return TExportSink_Header_DEFAULT
	}
	return *p.Header
}
func (p *TExportSink) SetFileType(val types.TFileType) {
	p.FileType = val
}
func (p *TExportSink) SetExportPath(val string) {
	p.ExportPath = val
}
func (p *TExportSink) SetColumnSeparator(val string) {
	p.ColumnSeparator = val
}
func (p *TExportSink) SetLineDelimiter(val string) {
	p.LineDelimiter = val
}
func (p *TExportSink) SetBrokerAddresses(val []*types.TNetworkAddress) {
	p.BrokerAddresses = val
}
func (p *TExportSink) SetProperties(val map[string]string) {
	p.Properties = val
}
func (p *TExportSink) SetHeader(val *string) {
	p.Header = val
}

var fieldIDToName_TExportSink = map[int16]string{
	1: "file_type",
	2: "export_path",
	3: "column_separator",
	4: "line_delimiter",
	5: "broker_addresses",
	6: "properties",
	7: "header",
}

func (p *TExportSink) IsSetBrokerAddresses() bool {
	return p.BrokerAddresses != nil
}

func (p *TExportSink) IsSetProperties() bool {
	return p.Properties != nil
}

func (p *TExportSink) IsSetHeader() bool {
	return p.Header != nil
}

func (p *TExportSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFileType bool = false
	var issetExportPath bool = false
	var issetColumnSeparator bool = false
	var issetLineDelimiter bool = false

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
				issetFileType = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
				issetExportPath = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
				issetColumnSeparator = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
				issetLineDelimiter = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err = p.ReadField5(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.MAP {
				if err = p.ReadField6(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField7(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	if !issetFileType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetExportPath {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetColumnSeparator {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetLineDelimiter {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TExportSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TExportSink[fieldId]))
}

func (p *TExportSink) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.FileType = types.TFileType(v)
	}
	return nil
}

func (p *TExportSink) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.ExportPath = v
	}
	return nil
}

func (p *TExportSink) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.ColumnSeparator = v
	}
	return nil
}

func (p *TExportSink) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.LineDelimiter = v
	}
	return nil
}

func (p *TExportSink) ReadField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return err
	}
	p.BrokerAddresses = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if err := _elem.Read(iprot); err != nil {
			return err
		}

		p.BrokerAddresses = append(p.BrokerAddresses, _elem)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TExportSink) ReadField6(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, err := iprot.ReadString(); err != nil {
			return err
		} else {
			_key = v
		}

		var _val string
		if v, err := iprot.ReadString(); err != nil {
			return err
		} else {
			_val = v
		}

		p.Properties[_key] = _val
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return err
	}
	return nil
}

func (p *TExportSink) ReadField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.Header = &v
	}
	return nil
}

func (p *TExportSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TExportSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}
		if err = p.writeField5(oprot); err != nil {
			fieldId = 5
			goto WriteFieldError
		}
		if err = p.writeField6(oprot); err != nil {
			fieldId = 6
			goto WriteFieldError
		}
		if err = p.writeField7(oprot); err != nil {
			fieldId = 7
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TExportSink) writeField1(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("file_type", thrift.I32, 1); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI32(int32(p.FileType)); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TExportSink) writeField2(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("export_path", thrift.STRING, 2); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.ExportPath); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TExportSink) writeField3(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("column_separator", thrift.STRING, 3); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.ColumnSeparator); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TExportSink) writeField4(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("line_delimiter", thrift.STRING, 4); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteString(p.LineDelimiter); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TExportSink) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetBrokerAddresses() {
		if err = oprot.WriteFieldBegin("broker_addresses", thrift.LIST, 5); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.BrokerAddresses)); err != nil {
			return err
		}
		for _, v := range p.BrokerAddresses {
			if err := v.Write(oprot); err != nil {
				return err
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 end error: ", p), err)
}

func (p *TExportSink) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetProperties() {
		if err = oprot.WriteFieldBegin("properties", thrift.MAP, 6); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Properties)); err != nil {
			return err
		}
		for k, v := range p.Properties {

			if err := oprot.WriteString(k); err != nil {
				return err
			}

			if err := oprot.WriteString(v); err != nil {
				return err
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 end error: ", p), err)
}

func (p *TExportSink) writeField7(oprot thrift.TProtocol) (err error) {
	if p.IsSetHeader() {
		if err = oprot.WriteFieldBegin("header", thrift.STRING, 7); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.Header); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 end error: ", p), err)
}

func (p *TExportSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TExportSink(%+v)", *p)
}

func (p *TExportSink) DeepEqual(ano *TExportSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.FileType) {
		return false
	}
	if !p.Field2DeepEqual(ano.ExportPath) {
		return false
	}
	if !p.Field3DeepEqual(ano.ColumnSeparator) {
		return false
	}
	if !p.Field4DeepEqual(ano.LineDelimiter) {
		return false
	}
	if !p.Field5DeepEqual(ano.BrokerAddresses) {
		return false
	}
	if !p.Field6DeepEqual(ano.Properties) {
		return false
	}
	if !p.Field7DeepEqual(ano.Header) {
		return false
	}
	return true
}

func (p *TExportSink) Field1DeepEqual(src types.TFileType) bool {

	if p.FileType != src {
		return false
	}
	return true
}
func (p *TExportSink) Field2DeepEqual(src string) bool {

	if strings.Compare(p.ExportPath, src) != 0 {
		return false
	}
	return true
}
func (p *TExportSink) Field3DeepEqual(src string) bool {

	if strings.Compare(p.ColumnSeparator, src) != 0 {
		return false
	}
	return true
}
func (p *TExportSink) Field4DeepEqual(src string) bool {

	if strings.Compare(p.LineDelimiter, src) != 0 {
		return false
	}
	return true
}
func (p *TExportSink) Field5DeepEqual(src []*types.TNetworkAddress) bool {

	if len(p.BrokerAddresses) != len(src) {
		return false
	}
	for i, v := range p.BrokerAddresses {
		_src := src[i]
		if !v.DeepEqual(_src) {
			return false
		}
	}
	return true
}
func (p *TExportSink) Field6DeepEqual(src map[string]string) bool {

	if len(p.Properties) != len(src) {
		return false
	}
	for k, v := range p.Properties {
		_src := src[k]
		if strings.Compare(v, _src) != 0 {
			return false
		}
	}
	return true
}
func (p *TExportSink) Field7DeepEqual(src *string) bool {

	if p.Header == src {
		return true
	} else if p.Header == nil || src == nil {
		return false
	}
	if strings.Compare(*p.Header, *src) != 0 {
		return false
	}
	return true
}

type TOlapTableSink struct {
	LoadId               *types.TUniqueId                      `thrift:"load_id,1,required" frugal:"1,required,types.TUniqueId" json:"load_id"`
	TxnId                int64                                 `thrift:"txn_id,2,required" frugal:"2,required,i64" json:"txn_id"`
	DbId                 int64                                 `thrift:"db_id,3,required" frugal:"3,required,i64" json:"db_id"`
	TableId              int64                                 `thrift:"table_id,4,required" frugal:"4,required,i64" json:"table_id"`
	TupleId              int32                                 `thrift:"tuple_id,5,required" frugal:"5,required,i32" json:"tuple_id"`
	NumReplicas          int32                                 `thrift:"num_replicas,6,required" frugal:"6,required,i32" json:"num_replicas"`
	NeedGenRollup        bool                                  `thrift:"need_gen_rollup,7,required" frugal:"7,required,bool" json:"need_gen_rollup"`
	DbName               *string                               `thrift:"db_name,8,optional" frugal:"8,optional,string" json:"db_name,omitempty"`
	TableName            *string                               `thrift:"table_name,9,optional" frugal:"9,optional,string" json:"table_name,omitempty"`
	Schema               *descriptors.TOlapTableSchemaParam    `thrift:"schema,10,required" frugal:"10,required,descriptors.TOlapTableSchemaParam" json:"schema"`
	Partition            *descriptors.TOlapTablePartitionParam `thrift:"partition,11,required" frugal:"11,required,descriptors.TOlapTablePartitionParam" json:"partition"`
	Location             *descriptors.TOlapTableLocationParam  `thrift:"location,12,required" frugal:"12,required,descriptors.TOlapTableLocationParam" json:"location"`
	NodesInfo            *descriptors.TPaloNodesInfo           `thrift:"nodes_info,13,required" frugal:"13,required,descriptors.TPaloNodesInfo" json:"nodes_info"`
	LoadChannelTimeoutS  *int64                                `thrift:"load_channel_timeout_s,14,optional" frugal:"14,optional,i64" json:"load_channel_timeout_s,omitempty"`
	SendBatchParallelism *int32                                `thrift:"send_batch_parallelism,15,optional" frugal:"15,optional,i32" json:"send_batch_parallelism,omitempty"`
	LoadToSingleTablet   *bool                                 `thrift:"load_to_single_tablet,16,optional" frugal:"16,optional,bool" json:"load_to_single_tablet,omitempty"`
	WriteSingleReplica   *bool                                 `thrift:"write_single_replica,17,optional" frugal:"17,optional,bool" json:"write_single_replica,omitempty"`
	SlaveLocation        *descriptors.TOlapTableLocationParam  `thrift:"slave_location,18,optional" frugal:"18,optional,descriptors.TOlapTableLocationParam" json:"slave_location,omitempty"`
	TxnTimeoutS          *int64                                `thrift:"txn_timeout_s,19,optional" frugal:"19,optional,i64" json:"txn_timeout_s,omitempty"`
	WriteFileCache       *bool                                 `thrift:"write_file_cache,20,optional" frugal:"20,optional,bool" json:"write_file_cache,omitempty"`
	BaseSchemaVersion    *int64                                `thrift:"base_schema_version,21,optional" frugal:"21,optional,i64" json:"base_schema_version,omitempty"`
}

func NewTOlapTableSink() *TOlapTableSink {
	return &TOlapTableSink{}
}

func (p *TOlapTableSink) InitDefault() {
	*p = TOlapTableSink{}
}

var TOlapTableSink_LoadId_DEFAULT *types.TUniqueId

func (p *TOlapTableSink) GetLoadId() (v *types.TUniqueId) {
	if !p.IsSetLoadId() {
		return TOlapTableSink_LoadId_DEFAULT
	}
	return p.LoadId
}

func (p *TOlapTableSink) GetTxnId() (v int64) {
	return p.TxnId
}

func (p *TOlapTableSink) GetDbId() (v int64) {
	return p.DbId
}

func (p *TOlapTableSink) GetTableId() (v int64) {
	return p.TableId
}

func (p *TOlapTableSink) GetTupleId() (v int32) {
	return p.TupleId
}

func (p *TOlapTableSink) GetNumReplicas() (v int32) {
	return p.NumReplicas
}

func (p *TOlapTableSink) GetNeedGenRollup() (v bool) {
	return p.NeedGenRollup
}

var TOlapTableSink_DbName_DEFAULT string

func (p *TOlapTableSink) GetDbName() (v string) {
	if !p.IsSetDbName() {
		return TOlapTableSink_DbName_DEFAULT
	}
	return *p.DbName
}

var TOlapTableSink_TableName_DEFAULT string

func (p *TOlapTableSink) GetTableName() (v string) {
	if !p.IsSetTableName() {
		return TOlapTableSink_TableName_DEFAULT
	}
	return *p.TableName
}

var TOlapTableSink_Schema_DEFAULT *descriptors.TOlapTableSchemaParam

func (p *TOlapTableSink) GetSchema() (v *descriptors.TOlapTableSchemaParam) {
	if !p.IsSetSchema() {
		return TOlapTableSink_Schema_DEFAULT
	}
	return p.Schema
}

var TOlapTableSink_Partition_DEFAULT *descriptors.TOlapTablePartitionParam

func (p *TOlapTableSink) GetPartition() (v *descriptors.TOlapTablePartitionParam) {
	if !p.IsSetPartition() {
		return TOlapTableSink_Partition_DEFAULT
	}
	return p.Partition
}

var TOlapTableSink_Location_DEFAULT *descriptors.TOlapTableLocationParam

func (p *TOlapTableSink) GetLocation() (v *descriptors.TOlapTableLocationParam) {
	if !p.IsSetLocation() {
		return TOlapTableSink_Location_DEFAULT
	}
	return p.Location
}

var TOlapTableSink_NodesInfo_DEFAULT *descriptors.TPaloNodesInfo

func (p *TOlapTableSink) GetNodesInfo() (v *descriptors.TPaloNodesInfo) {
	if !p.IsSetNodesInfo() {
		return TOlapTableSink_NodesInfo_DEFAULT
	}
	return p.NodesInfo
}

var TOlapTableSink_LoadChannelTimeoutS_DEFAULT int64

func (p *TOlapTableSink) GetLoadChannelTimeoutS() (v int64) {
	if !p.IsSetLoadChannelTimeoutS() {
		return TOlapTableSink_LoadChannelTimeoutS_DEFAULT
	}
	return *p.LoadChannelTimeoutS
}

var TOlapTableSink_SendBatchParallelism_DEFAULT int32

func (p *TOlapTableSink) GetSendBatchParallelism() (v int32) {
	if !p.IsSetSendBatchParallelism() {
		return TOlapTableSink_SendBatchParallelism_DEFAULT
	}
	return *p.SendBatchParallelism
}

var TOlapTableSink_LoadToSingleTablet_DEFAULT bool

func (p *TOlapTableSink) GetLoadToSingleTablet() (v bool) {
	if !p.IsSetLoadToSingleTablet() {
		return TOlapTableSink_LoadToSingleTablet_DEFAULT
	}
	return *p.LoadToSingleTablet
}

var TOlapTableSink_WriteSingleReplica_DEFAULT bool

func (p *TOlapTableSink) GetWriteSingleReplica() (v bool) {
	if !p.IsSetWriteSingleReplica() {
		return TOlapTableSink_WriteSingleReplica_DEFAULT
	}
	return *p.WriteSingleReplica
}

var TOlapTableSink_SlaveLocation_DEFAULT *descriptors.TOlapTableLocationParam

func (p *TOlapTableSink) GetSlaveLocation() (v *descriptors.TOlapTableLocationParam) {
	if !p.IsSetSlaveLocation() {
		return TOlapTableSink_SlaveLocation_DEFAULT
	}
	return p.SlaveLocation
}

var TOlapTableSink_TxnTimeoutS_DEFAULT int64

func (p *TOlapTableSink) GetTxnTimeoutS() (v int64) {
	if !p.IsSetTxnTimeoutS() {
		return TOlapTableSink_TxnTimeoutS_DEFAULT
	}
	return *p.TxnTimeoutS
}

var TOlapTableSink_WriteFileCache_DEFAULT bool

func (p *TOlapTableSink) GetWriteFileCache() (v bool) {
	if !p.IsSetWriteFileCache() {
		return TOlapTableSink_WriteFileCache_DEFAULT
	}
	return *p.WriteFileCache
}

var TOlapTableSink_BaseSchemaVersion_DEFAULT int64

func (p *TOlapTableSink) GetBaseSchemaVersion() (v int64) {
	if !p.IsSetBaseSchemaVersion() {
		return TOlapTableSink_BaseSchemaVersion_DEFAULT
	}
	return *p.BaseSchemaVersion
}
func (p *TOlapTableSink) SetLoadId(val *types.TUniqueId) {
	p.LoadId = val
}
func (p *TOlapTableSink) SetTxnId(val int64) {
	p.TxnId = val
}
func (p *TOlapTableSink) SetDbId(val int64) {
	p.DbId = val
}
func (p *TOlapTableSink) SetTableId(val int64) {
	p.TableId = val
}
func (p *TOlapTableSink) SetTupleId(val int32) {
	p.TupleId = val
}
func (p *TOlapTableSink) SetNumReplicas(val int32) {
	p.NumReplicas = val
}
func (p *TOlapTableSink) SetNeedGenRollup(val bool) {
	p.NeedGenRollup = val
}
func (p *TOlapTableSink) SetDbName(val *string) {
	p.DbName = val
}
func (p *TOlapTableSink) SetTableName(val *string) {
	p.TableName = val
}
func (p *TOlapTableSink) SetSchema(val *descriptors.TOlapTableSchemaParam) {
	p.Schema = val
}
func (p *TOlapTableSink) SetPartition(val *descriptors.TOlapTablePartitionParam) {
	p.Partition = val
}
func (p *TOlapTableSink) SetLocation(val *descriptors.TOlapTableLocationParam) {
	p.Location = val
}
func (p *TOlapTableSink) SetNodesInfo(val *descriptors.TPaloNodesInfo) {
	p.NodesInfo = val
}
func (p *TOlapTableSink) SetLoadChannelTimeoutS(val *int64) {
	p.LoadChannelTimeoutS = val
}
func (p *TOlapTableSink) SetSendBatchParallelism(val *int32) {
	p.SendBatchParallelism = val
}
func (p *TOlapTableSink) SetLoadToSingleTablet(val *bool) {
	p.LoadToSingleTablet = val
}
func (p *TOlapTableSink) SetWriteSingleReplica(val *bool) {
	p.WriteSingleReplica = val
}
func (p *TOlapTableSink) SetSlaveLocation(val *descriptors.TOlapTableLocationParam) {
	p.SlaveLocation = val
}
func (p *TOlapTableSink) SetTxnTimeoutS(val *int64) {
	p.TxnTimeoutS = val
}
func (p *TOlapTableSink) SetWriteFileCache(val *bool) {
	p.WriteFileCache = val
}
func (p *TOlapTableSink) SetBaseSchemaVersion(val *int64) {
	p.BaseSchemaVersion = val
}

var fieldIDToName_TOlapTableSink = map[int16]string{
	1:  "load_id",
	2:  "txn_id",
	3:  "db_id",
	4:  "table_id",
	5:  "tuple_id",
	6:  "num_replicas",
	7:  "need_gen_rollup",
	8:  "db_name",
	9:  "table_name",
	10: "schema",
	11: "partition",
	12: "location",
	13: "nodes_info",
	14: "load_channel_timeout_s",
	15: "send_batch_parallelism",
	16: "load_to_single_tablet",
	17: "write_single_replica",
	18: "slave_location",
	19: "txn_timeout_s",
	20: "write_file_cache",
	21: "base_schema_version",
}

func (p *TOlapTableSink) IsSetLoadId() bool {
	return p.LoadId != nil
}

func (p *TOlapTableSink) IsSetDbName() bool {
	return p.DbName != nil
}

func (p *TOlapTableSink) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *TOlapTableSink) IsSetSchema() bool {
	return p.Schema != nil
}

func (p *TOlapTableSink) IsSetPartition() bool {
	return p.Partition != nil
}

func (p *TOlapTableSink) IsSetLocation() bool {
	return p.Location != nil
}

func (p *TOlapTableSink) IsSetNodesInfo() bool {
	return p.NodesInfo != nil
}

func (p *TOlapTableSink) IsSetLoadChannelTimeoutS() bool {
	return p.LoadChannelTimeoutS != nil
}

func (p *TOlapTableSink) IsSetSendBatchParallelism() bool {
	return p.SendBatchParallelism != nil
}

func (p *TOlapTableSink) IsSetLoadToSingleTablet() bool {
	return p.LoadToSingleTablet != nil
}

func (p *TOlapTableSink) IsSetWriteSingleReplica() bool {
	return p.WriteSingleReplica != nil
}

func (p *TOlapTableSink) IsSetSlaveLocation() bool {
	return p.SlaveLocation != nil
}

func (p *TOlapTableSink) IsSetTxnTimeoutS() bool {
	return p.TxnTimeoutS != nil
}

func (p *TOlapTableSink) IsSetWriteFileCache() bool {
	return p.WriteFileCache != nil
}

func (p *TOlapTableSink) IsSetBaseSchemaVersion() bool {
	return p.BaseSchemaVersion != nil
}

func (p *TOlapTableSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16
	var issetLoadId bool = false
	var issetTxnId bool = false
	var issetDbId bool = false
	var issetTableId bool = false
	var issetTupleId bool = false
	var issetNumReplicas bool = false
	var issetNeedGenRollup bool = false
	var issetSchema bool = false
	var issetPartition bool = false
	var issetLocation bool = false
	var issetNodesInfo bool = false

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
				issetLoadId = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
				issetTxnId = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
				issetDbId = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err = p.ReadField4(iprot); err != nil {
					goto ReadFieldError
				}
				issetTableId = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField5(iprot); err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField6(iprot); err != nil {
					goto ReadFieldError
				}
				issetNumReplicas = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField7(iprot); err != nil {
					goto ReadFieldError
				}
				issetNeedGenRollup = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField8(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				if err = p.ReadField9(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField10(iprot); err != nil {
					goto ReadFieldError
				}
				issetSchema = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField11(iprot); err != nil {
					goto ReadFieldError
				}
				issetPartition = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField12(iprot); err != nil {
					goto ReadFieldError
				}
				issetLocation = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField13(iprot); err != nil {
					goto ReadFieldError
				}
				issetNodesInfo = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.I64 {
				if err = p.ReadField14(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField15(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField16(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField17(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField18(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.I64 {
				if err = p.ReadField19(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 20:
			if fieldTypeId == thrift.BOOL {
				if err = p.ReadField20(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 21:
			if fieldTypeId == thrift.I64 {
				if err = p.ReadField21(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	if !issetLoadId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTxnId {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetDbId {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetTableId {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetTupleId {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetNumReplicas {
		fieldId = 6
		goto RequiredFieldNotSetError
	}

	if !issetNeedGenRollup {
		fieldId = 7
		goto RequiredFieldNotSetError
	}

	if !issetSchema {
		fieldId = 10
		goto RequiredFieldNotSetError
	}

	if !issetPartition {
		fieldId = 11
		goto RequiredFieldNotSetError
	}

	if !issetLocation {
		fieldId = 12
		goto RequiredFieldNotSetError
	}

	if !issetNodesInfo {
		fieldId = 13
		goto RequiredFieldNotSetError
	}
	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTableSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTableSink[fieldId]))
}

func (p *TOlapTableSink) ReadField1(iprot thrift.TProtocol) error {
	p.LoadId = types.NewTUniqueId()
	if err := p.LoadId.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TOlapTableSink) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return err
	} else {
		p.TxnId = v
	}
	return nil
}

func (p *TOlapTableSink) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return err
	} else {
		p.DbId = v
	}
	return nil
}

func (p *TOlapTableSink) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return err
	} else {
		p.TableId = v
	}
	return nil
}

func (p *TOlapTableSink) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.TupleId = v
	}
	return nil
}

func (p *TOlapTableSink) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.NumReplicas = v
	}
	return nil
}

func (p *TOlapTableSink) ReadField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.NeedGenRollup = v
	}
	return nil
}

func (p *TOlapTableSink) ReadField8(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.DbName = &v
	}
	return nil
}

func (p *TOlapTableSink) ReadField9(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return err
	} else {
		p.TableName = &v
	}
	return nil
}

func (p *TOlapTableSink) ReadField10(iprot thrift.TProtocol) error {
	p.Schema = descriptors.NewTOlapTableSchemaParam()
	if err := p.Schema.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TOlapTableSink) ReadField11(iprot thrift.TProtocol) error {
	p.Partition = descriptors.NewTOlapTablePartitionParam()
	if err := p.Partition.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TOlapTableSink) ReadField12(iprot thrift.TProtocol) error {
	p.Location = descriptors.NewTOlapTableLocationParam()
	if err := p.Location.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TOlapTableSink) ReadField13(iprot thrift.TProtocol) error {
	p.NodesInfo = descriptors.NewTPaloNodesInfo()
	if err := p.NodesInfo.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TOlapTableSink) ReadField14(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return err
	} else {
		p.LoadChannelTimeoutS = &v
	}
	return nil
}

func (p *TOlapTableSink) ReadField15(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.SendBatchParallelism = &v
	}
	return nil
}

func (p *TOlapTableSink) ReadField16(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.LoadToSingleTablet = &v
	}
	return nil
}

func (p *TOlapTableSink) ReadField17(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.WriteSingleReplica = &v
	}
	return nil
}

func (p *TOlapTableSink) ReadField18(iprot thrift.TProtocol) error {
	p.SlaveLocation = descriptors.NewTOlapTableLocationParam()
	if err := p.SlaveLocation.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TOlapTableSink) ReadField19(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return err
	} else {
		p.TxnTimeoutS = &v
	}
	return nil
}

func (p *TOlapTableSink) ReadField20(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return err
	} else {
		p.WriteFileCache = &v
	}
	return nil
}

func (p *TOlapTableSink) ReadField21(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return err
	} else {
		p.BaseSchemaVersion = &v
	}
	return nil
}

func (p *TOlapTableSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TOlapTableSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField4(oprot); err != nil {
			fieldId = 4
			goto WriteFieldError
		}
		if err = p.writeField5(oprot); err != nil {
			fieldId = 5
			goto WriteFieldError
		}
		if err = p.writeField6(oprot); err != nil {
			fieldId = 6
			goto WriteFieldError
		}
		if err = p.writeField7(oprot); err != nil {
			fieldId = 7
			goto WriteFieldError
		}
		if err = p.writeField8(oprot); err != nil {
			fieldId = 8
			goto WriteFieldError
		}
		if err = p.writeField9(oprot); err != nil {
			fieldId = 9
			goto WriteFieldError
		}
		if err = p.writeField10(oprot); err != nil {
			fieldId = 10
			goto WriteFieldError
		}
		if err = p.writeField11(oprot); err != nil {
			fieldId = 11
			goto WriteFieldError
		}
		if err = p.writeField12(oprot); err != nil {
			fieldId = 12
			goto WriteFieldError
		}
		if err = p.writeField13(oprot); err != nil {
			fieldId = 13
			goto WriteFieldError
		}
		if err = p.writeField14(oprot); err != nil {
			fieldId = 14
			goto WriteFieldError
		}
		if err = p.writeField15(oprot); err != nil {
			fieldId = 15
			goto WriteFieldError
		}
		if err = p.writeField16(oprot); err != nil {
			fieldId = 16
			goto WriteFieldError
		}
		if err = p.writeField17(oprot); err != nil {
			fieldId = 17
			goto WriteFieldError
		}
		if err = p.writeField18(oprot); err != nil {
			fieldId = 18
			goto WriteFieldError
		}
		if err = p.writeField19(oprot); err != nil {
			fieldId = 19
			goto WriteFieldError
		}
		if err = p.writeField20(oprot); err != nil {
			fieldId = 20
			goto WriteFieldError
		}
		if err = p.writeField21(oprot); err != nil {
			fieldId = 21
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TOlapTableSink) writeField1(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("load_id", thrift.STRUCT, 1); err != nil {
		goto WriteFieldBeginError
	}
	if err := p.LoadId.Write(oprot); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TOlapTableSink) writeField2(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("txn_id", thrift.I64, 2); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI64(p.TxnId); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TOlapTableSink) writeField3(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("db_id", thrift.I64, 3); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI64(p.DbId); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TOlapTableSink) writeField4(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("table_id", thrift.I64, 4); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI64(p.TableId); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 4 end error: ", p), err)
}

func (p *TOlapTableSink) writeField5(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("tuple_id", thrift.I32, 5); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI32(p.TupleId); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 end error: ", p), err)
}

func (p *TOlapTableSink) writeField6(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("num_replicas", thrift.I32, 6); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI32(p.NumReplicas); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 end error: ", p), err)
}

func (p *TOlapTableSink) writeField7(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("need_gen_rollup", thrift.BOOL, 7); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteBool(p.NeedGenRollup); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 end error: ", p), err)
}

func (p *TOlapTableSink) writeField8(oprot thrift.TProtocol) (err error) {
	if p.IsSetDbName() {
		if err = oprot.WriteFieldBegin("db_name", thrift.STRING, 8); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.DbName); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 8 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 8 end error: ", p), err)
}

func (p *TOlapTableSink) writeField9(oprot thrift.TProtocol) (err error) {
	if p.IsSetTableName() {
		if err = oprot.WriteFieldBegin("table_name", thrift.STRING, 9); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteString(*p.TableName); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 9 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 9 end error: ", p), err)
}

func (p *TOlapTableSink) writeField10(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("schema", thrift.STRUCT, 10); err != nil {
		goto WriteFieldBeginError
	}
	if err := p.Schema.Write(oprot); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 10 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 10 end error: ", p), err)
}

func (p *TOlapTableSink) writeField11(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("partition", thrift.STRUCT, 11); err != nil {
		goto WriteFieldBeginError
	}
	if err := p.Partition.Write(oprot); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 11 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 11 end error: ", p), err)
}

func (p *TOlapTableSink) writeField12(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("location", thrift.STRUCT, 12); err != nil {
		goto WriteFieldBeginError
	}
	if err := p.Location.Write(oprot); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 12 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 12 end error: ", p), err)
}

func (p *TOlapTableSink) writeField13(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("nodes_info", thrift.STRUCT, 13); err != nil {
		goto WriteFieldBeginError
	}
	if err := p.NodesInfo.Write(oprot); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 13 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 13 end error: ", p), err)
}

func (p *TOlapTableSink) writeField14(oprot thrift.TProtocol) (err error) {
	if p.IsSetLoadChannelTimeoutS() {
		if err = oprot.WriteFieldBegin("load_channel_timeout_s", thrift.I64, 14); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI64(*p.LoadChannelTimeoutS); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 14 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 14 end error: ", p), err)
}

func (p *TOlapTableSink) writeField15(oprot thrift.TProtocol) (err error) {
	if p.IsSetSendBatchParallelism() {
		if err = oprot.WriteFieldBegin("send_batch_parallelism", thrift.I32, 15); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI32(*p.SendBatchParallelism); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 15 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 15 end error: ", p), err)
}

func (p *TOlapTableSink) writeField16(oprot thrift.TProtocol) (err error) {
	if p.IsSetLoadToSingleTablet() {
		if err = oprot.WriteFieldBegin("load_to_single_tablet", thrift.BOOL, 16); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.LoadToSingleTablet); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 16 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 16 end error: ", p), err)
}

func (p *TOlapTableSink) writeField17(oprot thrift.TProtocol) (err error) {
	if p.IsSetWriteSingleReplica() {
		if err = oprot.WriteFieldBegin("write_single_replica", thrift.BOOL, 17); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.WriteSingleReplica); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 17 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 17 end error: ", p), err)
}

func (p *TOlapTableSink) writeField18(oprot thrift.TProtocol) (err error) {
	if p.IsSetSlaveLocation() {
		if err = oprot.WriteFieldBegin("slave_location", thrift.STRUCT, 18); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.SlaveLocation.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 18 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 18 end error: ", p), err)
}

func (p *TOlapTableSink) writeField19(oprot thrift.TProtocol) (err error) {
	if p.IsSetTxnTimeoutS() {
		if err = oprot.WriteFieldBegin("txn_timeout_s", thrift.I64, 19); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI64(*p.TxnTimeoutS); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 19 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 19 end error: ", p), err)
}

func (p *TOlapTableSink) writeField20(oprot thrift.TProtocol) (err error) {
	if p.IsSetWriteFileCache() {
		if err = oprot.WriteFieldBegin("write_file_cache", thrift.BOOL, 20); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteBool(*p.WriteFileCache); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 20 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 20 end error: ", p), err)
}

func (p *TOlapTableSink) writeField21(oprot thrift.TProtocol) (err error) {
	if p.IsSetBaseSchemaVersion() {
		if err = oprot.WriteFieldBegin("base_schema_version", thrift.I64, 21); err != nil {
			goto WriteFieldBeginError
		}
		if err := oprot.WriteI64(*p.BaseSchemaVersion); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 21 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 21 end error: ", p), err)
}

func (p *TOlapTableSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TOlapTableSink(%+v)", *p)
}

func (p *TOlapTableSink) DeepEqual(ano *TOlapTableSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.LoadId) {
		return false
	}
	if !p.Field2DeepEqual(ano.TxnId) {
		return false
	}
	if !p.Field3DeepEqual(ano.DbId) {
		return false
	}
	if !p.Field4DeepEqual(ano.TableId) {
		return false
	}
	if !p.Field5DeepEqual(ano.TupleId) {
		return false
	}
	if !p.Field6DeepEqual(ano.NumReplicas) {
		return false
	}
	if !p.Field7DeepEqual(ano.NeedGenRollup) {
		return false
	}
	if !p.Field8DeepEqual(ano.DbName) {
		return false
	}
	if !p.Field9DeepEqual(ano.TableName) {
		return false
	}
	if !p.Field10DeepEqual(ano.Schema) {
		return false
	}
	if !p.Field11DeepEqual(ano.Partition) {
		return false
	}
	if !p.Field12DeepEqual(ano.Location) {
		return false
	}
	if !p.Field13DeepEqual(ano.NodesInfo) {
		return false
	}
	if !p.Field14DeepEqual(ano.LoadChannelTimeoutS) {
		return false
	}
	if !p.Field15DeepEqual(ano.SendBatchParallelism) {
		return false
	}
	if !p.Field16DeepEqual(ano.LoadToSingleTablet) {
		return false
	}
	if !p.Field17DeepEqual(ano.WriteSingleReplica) {
		return false
	}
	if !p.Field18DeepEqual(ano.SlaveLocation) {
		return false
	}
	if !p.Field19DeepEqual(ano.TxnTimeoutS) {
		return false
	}
	if !p.Field20DeepEqual(ano.WriteFileCache) {
		return false
	}
	if !p.Field21DeepEqual(ano.BaseSchemaVersion) {
		return false
	}
	return true
}

func (p *TOlapTableSink) Field1DeepEqual(src *types.TUniqueId) bool {

	if !p.LoadId.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field2DeepEqual(src int64) bool {

	if p.TxnId != src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field3DeepEqual(src int64) bool {

	if p.DbId != src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field4DeepEqual(src int64) bool {

	if p.TableId != src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field5DeepEqual(src int32) bool {

	if p.TupleId != src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field6DeepEqual(src int32) bool {

	if p.NumReplicas != src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field7DeepEqual(src bool) bool {

	if p.NeedGenRollup != src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field8DeepEqual(src *string) bool {

	if p.DbName == src {
		return true
	} else if p.DbName == nil || src == nil {
		return false
	}
	if strings.Compare(*p.DbName, *src) != 0 {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field9DeepEqual(src *string) bool {

	if p.TableName == src {
		return true
	} else if p.TableName == nil || src == nil {
		return false
	}
	if strings.Compare(*p.TableName, *src) != 0 {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field10DeepEqual(src *descriptors.TOlapTableSchemaParam) bool {

	if !p.Schema.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field11DeepEqual(src *descriptors.TOlapTablePartitionParam) bool {

	if !p.Partition.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field12DeepEqual(src *descriptors.TOlapTableLocationParam) bool {

	if !p.Location.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field13DeepEqual(src *descriptors.TPaloNodesInfo) bool {

	if !p.NodesInfo.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field14DeepEqual(src *int64) bool {

	if p.LoadChannelTimeoutS == src {
		return true
	} else if p.LoadChannelTimeoutS == nil || src == nil {
		return false
	}
	if *p.LoadChannelTimeoutS != *src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field15DeepEqual(src *int32) bool {

	if p.SendBatchParallelism == src {
		return true
	} else if p.SendBatchParallelism == nil || src == nil {
		return false
	}
	if *p.SendBatchParallelism != *src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field16DeepEqual(src *bool) bool {

	if p.LoadToSingleTablet == src {
		return true
	} else if p.LoadToSingleTablet == nil || src == nil {
		return false
	}
	if *p.LoadToSingleTablet != *src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field17DeepEqual(src *bool) bool {

	if p.WriteSingleReplica == src {
		return true
	} else if p.WriteSingleReplica == nil || src == nil {
		return false
	}
	if *p.WriteSingleReplica != *src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field18DeepEqual(src *descriptors.TOlapTableLocationParam) bool {

	if !p.SlaveLocation.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field19DeepEqual(src *int64) bool {

	if p.TxnTimeoutS == src {
		return true
	} else if p.TxnTimeoutS == nil || src == nil {
		return false
	}
	if *p.TxnTimeoutS != *src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field20DeepEqual(src *bool) bool {

	if p.WriteFileCache == src {
		return true
	} else if p.WriteFileCache == nil || src == nil {
		return false
	}
	if *p.WriteFileCache != *src {
		return false
	}
	return true
}
func (p *TOlapTableSink) Field21DeepEqual(src *int64) bool {

	if p.BaseSchemaVersion == src {
		return true
	} else if p.BaseSchemaVersion == nil || src == nil {
		return false
	}
	if *p.BaseSchemaVersion != *src {
		return false
	}
	return true
}

type TDataSink struct {
	Type                TDataSinkType             `thrift:"type,1,required" frugal:"1,required,TDataSinkType" json:"type"`
	StreamSink          *TDataStreamSink          `thrift:"stream_sink,2,optional" frugal:"2,optional,TDataStreamSink" json:"stream_sink,omitempty"`
	ResultSink          *TResultSink              `thrift:"result_sink,3,optional" frugal:"3,optional,TResultSink" json:"result_sink,omitempty"`
	MysqlTableSink      *TMysqlTableSink          `thrift:"mysql_table_sink,5,optional" frugal:"5,optional,TMysqlTableSink" json:"mysql_table_sink,omitempty"`
	ExportSink          *TExportSink              `thrift:"export_sink,6,optional" frugal:"6,optional,TExportSink" json:"export_sink,omitempty"`
	OlapTableSink       *TOlapTableSink           `thrift:"olap_table_sink,7,optional" frugal:"7,optional,TOlapTableSink" json:"olap_table_sink,omitempty"`
	MemoryScratchSink   *TMemoryScratchSink       `thrift:"memory_scratch_sink,8,optional" frugal:"8,optional,TMemoryScratchSink" json:"memory_scratch_sink,omitempty"`
	OdbcTableSink       *TOdbcTableSink           `thrift:"odbc_table_sink,9,optional" frugal:"9,optional,TOdbcTableSink" json:"odbc_table_sink,omitempty"`
	ResultFileSink      *TResultFileSink          `thrift:"result_file_sink,10,optional" frugal:"10,optional,TResultFileSink" json:"result_file_sink,omitempty"`
	JdbcTableSink       *TJdbcTableSink           `thrift:"jdbc_table_sink,11,optional" frugal:"11,optional,TJdbcTableSink" json:"jdbc_table_sink,omitempty"`
	MultiCastStreamSink *TMultiCastDataStreamSink `thrift:"multi_cast_stream_sink,12,optional" frugal:"12,optional,TMultiCastDataStreamSink" json:"multi_cast_stream_sink,omitempty"`
}

func NewTDataSink() *TDataSink {
	return &TDataSink{}
}

func (p *TDataSink) InitDefault() {
	*p = TDataSink{}
}

func (p *TDataSink) GetType() (v TDataSinkType) {
	return p.Type
}

var TDataSink_StreamSink_DEFAULT *TDataStreamSink

func (p *TDataSink) GetStreamSink() (v *TDataStreamSink) {
	if !p.IsSetStreamSink() {
		return TDataSink_StreamSink_DEFAULT
	}
	return p.StreamSink
}

var TDataSink_ResultSink_DEFAULT *TResultSink

func (p *TDataSink) GetResultSink() (v *TResultSink) {
	if !p.IsSetResultSink() {
		return TDataSink_ResultSink_DEFAULT
	}
	return p.ResultSink
}

var TDataSink_MysqlTableSink_DEFAULT *TMysqlTableSink

func (p *TDataSink) GetMysqlTableSink() (v *TMysqlTableSink) {
	if !p.IsSetMysqlTableSink() {
		return TDataSink_MysqlTableSink_DEFAULT
	}
	return p.MysqlTableSink
}

var TDataSink_ExportSink_DEFAULT *TExportSink

func (p *TDataSink) GetExportSink() (v *TExportSink) {
	if !p.IsSetExportSink() {
		return TDataSink_ExportSink_DEFAULT
	}
	return p.ExportSink
}

var TDataSink_OlapTableSink_DEFAULT *TOlapTableSink

func (p *TDataSink) GetOlapTableSink() (v *TOlapTableSink) {
	if !p.IsSetOlapTableSink() {
		return TDataSink_OlapTableSink_DEFAULT
	}
	return p.OlapTableSink
}

var TDataSink_MemoryScratchSink_DEFAULT *TMemoryScratchSink

func (p *TDataSink) GetMemoryScratchSink() (v *TMemoryScratchSink) {
	if !p.IsSetMemoryScratchSink() {
		return TDataSink_MemoryScratchSink_DEFAULT
	}
	return p.MemoryScratchSink
}

var TDataSink_OdbcTableSink_DEFAULT *TOdbcTableSink

func (p *TDataSink) GetOdbcTableSink() (v *TOdbcTableSink) {
	if !p.IsSetOdbcTableSink() {
		return TDataSink_OdbcTableSink_DEFAULT
	}
	return p.OdbcTableSink
}

var TDataSink_ResultFileSink_DEFAULT *TResultFileSink

func (p *TDataSink) GetResultFileSink() (v *TResultFileSink) {
	if !p.IsSetResultFileSink() {
		return TDataSink_ResultFileSink_DEFAULT
	}
	return p.ResultFileSink
}

var TDataSink_JdbcTableSink_DEFAULT *TJdbcTableSink

func (p *TDataSink) GetJdbcTableSink() (v *TJdbcTableSink) {
	if !p.IsSetJdbcTableSink() {
		return TDataSink_JdbcTableSink_DEFAULT
	}
	return p.JdbcTableSink
}

var TDataSink_MultiCastStreamSink_DEFAULT *TMultiCastDataStreamSink

func (p *TDataSink) GetMultiCastStreamSink() (v *TMultiCastDataStreamSink) {
	if !p.IsSetMultiCastStreamSink() {
		return TDataSink_MultiCastStreamSink_DEFAULT
	}
	return p.MultiCastStreamSink
}
func (p *TDataSink) SetType(val TDataSinkType) {
	p.Type = val
}
func (p *TDataSink) SetStreamSink(val *TDataStreamSink) {
	p.StreamSink = val
}
func (p *TDataSink) SetResultSink(val *TResultSink) {
	p.ResultSink = val
}
func (p *TDataSink) SetMysqlTableSink(val *TMysqlTableSink) {
	p.MysqlTableSink = val
}
func (p *TDataSink) SetExportSink(val *TExportSink) {
	p.ExportSink = val
}
func (p *TDataSink) SetOlapTableSink(val *TOlapTableSink) {
	p.OlapTableSink = val
}
func (p *TDataSink) SetMemoryScratchSink(val *TMemoryScratchSink) {
	p.MemoryScratchSink = val
}
func (p *TDataSink) SetOdbcTableSink(val *TOdbcTableSink) {
	p.OdbcTableSink = val
}
func (p *TDataSink) SetResultFileSink(val *TResultFileSink) {
	p.ResultFileSink = val
}
func (p *TDataSink) SetJdbcTableSink(val *TJdbcTableSink) {
	p.JdbcTableSink = val
}
func (p *TDataSink) SetMultiCastStreamSink(val *TMultiCastDataStreamSink) {
	p.MultiCastStreamSink = val
}

var fieldIDToName_TDataSink = map[int16]string{
	1:  "type",
	2:  "stream_sink",
	3:  "result_sink",
	5:  "mysql_table_sink",
	6:  "export_sink",
	7:  "olap_table_sink",
	8:  "memory_scratch_sink",
	9:  "odbc_table_sink",
	10: "result_file_sink",
	11: "jdbc_table_sink",
	12: "multi_cast_stream_sink",
}

func (p *TDataSink) IsSetStreamSink() bool {
	return p.StreamSink != nil
}

func (p *TDataSink) IsSetResultSink() bool {
	return p.ResultSink != nil
}

func (p *TDataSink) IsSetMysqlTableSink() bool {
	return p.MysqlTableSink != nil
}

func (p *TDataSink) IsSetExportSink() bool {
	return p.ExportSink != nil
}

func (p *TDataSink) IsSetOlapTableSink() bool {
	return p.OlapTableSink != nil
}

func (p *TDataSink) IsSetMemoryScratchSink() bool {
	return p.MemoryScratchSink != nil
}

func (p *TDataSink) IsSetOdbcTableSink() bool {
	return p.OdbcTableSink != nil
}

func (p *TDataSink) IsSetResultFileSink() bool {
	return p.ResultFileSink != nil
}

func (p *TDataSink) IsSetJdbcTableSink() bool {
	return p.JdbcTableSink != nil
}

func (p *TDataSink) IsSetMultiCastStreamSink() bool {
	return p.MultiCastStreamSink != nil
}

func (p *TDataSink) Read(iprot thrift.TProtocol) (err error) {

	var fieldTypeId thrift.TType
	var fieldId int16
	var issetType bool = false

	if _, err = iprot.ReadStructBegin(); err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}

		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err = p.ReadField1(iprot); err != nil {
					goto ReadFieldError
				}
				issetType = true
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField2(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField3(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField5(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField6(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField7(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField8(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField9(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField10(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField11(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRUCT {
				if err = p.ReadField12(iprot); err != nil {
					goto ReadFieldError
				}
			} else {
				if err = iprot.Skip(fieldTypeId); err != nil {
					goto SkipFieldError
				}
			}
		default:
			if err = iprot.Skip(fieldTypeId); err != nil {
				goto SkipFieldError
			}
		}

		if err = iprot.ReadFieldEnd(); err != nil {
			goto ReadFieldEndError
		}
	}
	if err = iprot.ReadStructEnd(); err != nil {
		goto ReadStructEndError
	}

	if !issetType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return nil
ReadStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TDataSink[fieldId]), err)
SkipFieldError:
	return thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)

ReadFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TDataSink[fieldId]))
}

func (p *TDataSink) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return err
	} else {
		p.Type = TDataSinkType(v)
	}
	return nil
}

func (p *TDataSink) ReadField2(iprot thrift.TProtocol) error {
	p.StreamSink = NewTDataStreamSink()
	if err := p.StreamSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField3(iprot thrift.TProtocol) error {
	p.ResultSink = NewTResultSink()
	if err := p.ResultSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField5(iprot thrift.TProtocol) error {
	p.MysqlTableSink = NewTMysqlTableSink()
	if err := p.MysqlTableSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField6(iprot thrift.TProtocol) error {
	p.ExportSink = NewTExportSink()
	if err := p.ExportSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField7(iprot thrift.TProtocol) error {
	p.OlapTableSink = NewTOlapTableSink()
	if err := p.OlapTableSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField8(iprot thrift.TProtocol) error {
	p.MemoryScratchSink = NewTMemoryScratchSink()
	if err := p.MemoryScratchSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField9(iprot thrift.TProtocol) error {
	p.OdbcTableSink = NewTOdbcTableSink()
	if err := p.OdbcTableSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField10(iprot thrift.TProtocol) error {
	p.ResultFileSink = NewTResultFileSink()
	if err := p.ResultFileSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField11(iprot thrift.TProtocol) error {
	p.JdbcTableSink = NewTJdbcTableSink()
	if err := p.JdbcTableSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) ReadField12(iprot thrift.TProtocol) error {
	p.MultiCastStreamSink = NewTMultiCastDataStreamSink()
	if err := p.MultiCastStreamSink.Read(iprot); err != nil {
		return err
	}
	return nil
}

func (p *TDataSink) Write(oprot thrift.TProtocol) (err error) {
	var fieldId int16
	if err = oprot.WriteStructBegin("TDataSink"); err != nil {
		goto WriteStructBeginError
	}
	if p != nil {
		if err = p.writeField1(oprot); err != nil {
			fieldId = 1
			goto WriteFieldError
		}
		if err = p.writeField2(oprot); err != nil {
			fieldId = 2
			goto WriteFieldError
		}
		if err = p.writeField3(oprot); err != nil {
			fieldId = 3
			goto WriteFieldError
		}
		if err = p.writeField5(oprot); err != nil {
			fieldId = 5
			goto WriteFieldError
		}
		if err = p.writeField6(oprot); err != nil {
			fieldId = 6
			goto WriteFieldError
		}
		if err = p.writeField7(oprot); err != nil {
			fieldId = 7
			goto WriteFieldError
		}
		if err = p.writeField8(oprot); err != nil {
			fieldId = 8
			goto WriteFieldError
		}
		if err = p.writeField9(oprot); err != nil {
			fieldId = 9
			goto WriteFieldError
		}
		if err = p.writeField10(oprot); err != nil {
			fieldId = 10
			goto WriteFieldError
		}
		if err = p.writeField11(oprot); err != nil {
			fieldId = 11
			goto WriteFieldError
		}
		if err = p.writeField12(oprot); err != nil {
			fieldId = 12
			goto WriteFieldError
		}

	}
	if err = oprot.WriteFieldStop(); err != nil {
		goto WriteFieldStopError
	}
	if err = oprot.WriteStructEnd(); err != nil {
		goto WriteStructEndError
	}
	return nil
WriteStructBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
WriteFieldError:
	return thrift.PrependError(fmt.Sprintf("%T write field %d error: ", p, fieldId), err)
WriteFieldStopError:
	return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", p), err)
WriteStructEndError:
	return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", p), err)
}

func (p *TDataSink) writeField1(oprot thrift.TProtocol) (err error) {
	if err = oprot.WriteFieldBegin("type", thrift.I32, 1); err != nil {
		goto WriteFieldBeginError
	}
	if err := oprot.WriteI32(int32(p.Type)); err != nil {
		return err
	}
	if err = oprot.WriteFieldEnd(); err != nil {
		goto WriteFieldEndError
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 1 end error: ", p), err)
}

func (p *TDataSink) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetStreamSink() {
		if err = oprot.WriteFieldBegin("stream_sink", thrift.STRUCT, 2); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.StreamSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 2 end error: ", p), err)
}

func (p *TDataSink) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetResultSink() {
		if err = oprot.WriteFieldBegin("result_sink", thrift.STRUCT, 3); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.ResultSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 3 end error: ", p), err)
}

func (p *TDataSink) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetMysqlTableSink() {
		if err = oprot.WriteFieldBegin("mysql_table_sink", thrift.STRUCT, 5); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.MysqlTableSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 5 end error: ", p), err)
}

func (p *TDataSink) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetExportSink() {
		if err = oprot.WriteFieldBegin("export_sink", thrift.STRUCT, 6); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.ExportSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 6 end error: ", p), err)
}

func (p *TDataSink) writeField7(oprot thrift.TProtocol) (err error) {
	if p.IsSetOlapTableSink() {
		if err = oprot.WriteFieldBegin("olap_table_sink", thrift.STRUCT, 7); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.OlapTableSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 7 end error: ", p), err)
}

func (p *TDataSink) writeField8(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemoryScratchSink() {
		if err = oprot.WriteFieldBegin("memory_scratch_sink", thrift.STRUCT, 8); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.MemoryScratchSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 8 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 8 end error: ", p), err)
}

func (p *TDataSink) writeField9(oprot thrift.TProtocol) (err error) {
	if p.IsSetOdbcTableSink() {
		if err = oprot.WriteFieldBegin("odbc_table_sink", thrift.STRUCT, 9); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.OdbcTableSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 9 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 9 end error: ", p), err)
}

func (p *TDataSink) writeField10(oprot thrift.TProtocol) (err error) {
	if p.IsSetResultFileSink() {
		if err = oprot.WriteFieldBegin("result_file_sink", thrift.STRUCT, 10); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.ResultFileSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 10 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 10 end error: ", p), err)
}

func (p *TDataSink) writeField11(oprot thrift.TProtocol) (err error) {
	if p.IsSetJdbcTableSink() {
		if err = oprot.WriteFieldBegin("jdbc_table_sink", thrift.STRUCT, 11); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.JdbcTableSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 11 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 11 end error: ", p), err)
}

func (p *TDataSink) writeField12(oprot thrift.TProtocol) (err error) {
	if p.IsSetMultiCastStreamSink() {
		if err = oprot.WriteFieldBegin("multi_cast_stream_sink", thrift.STRUCT, 12); err != nil {
			goto WriteFieldBeginError
		}
		if err := p.MultiCastStreamSink.Write(oprot); err != nil {
			return err
		}
		if err = oprot.WriteFieldEnd(); err != nil {
			goto WriteFieldEndError
		}
	}
	return nil
WriteFieldBeginError:
	return thrift.PrependError(fmt.Sprintf("%T write field 12 begin error: ", p), err)
WriteFieldEndError:
	return thrift.PrependError(fmt.Sprintf("%T write field 12 end error: ", p), err)
}

func (p *TDataSink) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TDataSink(%+v)", *p)
}

func (p *TDataSink) DeepEqual(ano *TDataSink) bool {
	if p == ano {
		return true
	} else if p == nil || ano == nil {
		return false
	}
	if !p.Field1DeepEqual(ano.Type) {
		return false
	}
	if !p.Field2DeepEqual(ano.StreamSink) {
		return false
	}
	if !p.Field3DeepEqual(ano.ResultSink) {
		return false
	}
	if !p.Field5DeepEqual(ano.MysqlTableSink) {
		return false
	}
	if !p.Field6DeepEqual(ano.ExportSink) {
		return false
	}
	if !p.Field7DeepEqual(ano.OlapTableSink) {
		return false
	}
	if !p.Field8DeepEqual(ano.MemoryScratchSink) {
		return false
	}
	if !p.Field9DeepEqual(ano.OdbcTableSink) {
		return false
	}
	if !p.Field10DeepEqual(ano.ResultFileSink) {
		return false
	}
	if !p.Field11DeepEqual(ano.JdbcTableSink) {
		return false
	}
	if !p.Field12DeepEqual(ano.MultiCastStreamSink) {
		return false
	}
	return true
}

func (p *TDataSink) Field1DeepEqual(src TDataSinkType) bool {

	if p.Type != src {
		return false
	}
	return true
}
func (p *TDataSink) Field2DeepEqual(src *TDataStreamSink) bool {

	if !p.StreamSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field3DeepEqual(src *TResultSink) bool {

	if !p.ResultSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field5DeepEqual(src *TMysqlTableSink) bool {

	if !p.MysqlTableSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field6DeepEqual(src *TExportSink) bool {

	if !p.ExportSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field7DeepEqual(src *TOlapTableSink) bool {

	if !p.OlapTableSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field8DeepEqual(src *TMemoryScratchSink) bool {

	if !p.MemoryScratchSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field9DeepEqual(src *TOdbcTableSink) bool {

	if !p.OdbcTableSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field10DeepEqual(src *TResultFileSink) bool {

	if !p.ResultFileSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field11DeepEqual(src *TJdbcTableSink) bool {

	if !p.JdbcTableSink.DeepEqual(src) {
		return false
	}
	return true
}
func (p *TDataSink) Field12DeepEqual(src *TMultiCastDataStreamSink) bool {

	if !p.MultiCastStreamSink.DeepEqual(src) {
		return false
	}
	return true
}
